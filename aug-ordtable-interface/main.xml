<?xml version="1.0" encoding="UTF-8"?>
<block name='chapter'>
<field name='title'>
<![CDATA[
Augmented OrdTable Interface
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Augmented OrdTable Interface
]]>
</field> <!-- title_src -->
<field name='label'>
ch:aug-ordtable-interface
</field> <!-- label -->
<atom name='preamble'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>AUG_ORDTABLE</code> interface specifies a mapping from keys to values, augmented with efficient retrieval of reduced values for ranges of keys. Tables do not have duplicate keys, so there is a unique associated value for each key in the domain of a table. The key type is given by the <code>Key</code> substructure. The value type is given by the <code>Val</code> substructure.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{AUG\_ORDTABLE} interface specifies a mapping from keys to values,
augmented with
efficient retrieval of reduced values for ranges of keys. Tables do not have
duplicate
keys, so there is a unique associated value for each key in the domain of
a table. The key type is given by the \sml{Key} substructure. The value type
is given by the \sml{Val} substructure.
]]>
</field> <!-- body_src -->
</atom> <!-- preamble -->
<atom name='note'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>AUG_ORDTABLE</code> signature is nearly identical to <code>ORDTABLE</code> except for the following.</p>
<ul>
<li><p>Tables are no longer polymorphic in the type of values associated with keys.</p></li>
<li><p>There is now a <a href="#gr:aug-ordtable-interface:Val" data-reference-type="ref" data-reference="gr:aug-ordtable-interface:Val">[gr:aug-ordtable-interface:Val]</a> substructure which fixes the value type, and specifies how reduced values are computed.</p></li>
<li><p>The <a href="#gr:aug-ordtable-interface:reduceVal" data-reference-type="ref" data-reference="gr:aug-ordtable-interface:reduceVal">[gr:aug-ordtable-interface:reduceVal]</a> function retrieves reduced values.</p></li>
<li><p>The functions <code>collect</code> and <code>iteratePrefixes</code> have been removed, since these rely upon a polymorphic value type.</p></li>
</ul>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{AUG\_ORDTABLE} signature is nearly identical to \sml{ORDTABLE} except
for the following.
\begin{itemize}
  \item Tables are no longer polymorphic in the type of values associated with
  keys.
  \item There is now a \ref{gr:aug-ordtable-interface:Val} substructure which
  fixes the value type, and specifies how reduced values are computed.
  \item The \ref{gr:aug-ordtable-interface:reduceVal} function retrieves
  reduced values.
  \item The functions \sml{collect} and \sml{iteratePrefixes} have been
  removed, since these rely upon a polymorphic value type.
\end{itemize}
]]>
</field> <!-- body_src -->
</atom> <!-- note -->

<block name='section'>
<field name='title'>
<![CDATA[
Augmented, Ordered Tables
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Augmented, Ordered Tables
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->

<block name='subsection'>
<field name='title'>
<![CDATA[
Summary
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Summary
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>signature AUG_ORDTABLE =  
sig  
  structure Key : ORDKEY  
  structure Val : MONOID  
  structure Seq : SEQUENCE  
  
  type t  
  type table = t  
  
  structure Set : ORDSET where Key = Key and Seq = Seq  
  
  exception Order  
  
  val size : table -&gt; int  
  val domain : table -&gt; Set.t  
  val range : table -&gt; Val.t Seq.t  
  val toString : table -&gt; string  
  val toSeq : table -&gt; (Key.t * Val.t) Seq.t  
  
  val find : table -&gt; Key.t -&gt; Val.t option  
  val insert : table * (Key.t * Val.t) -&gt; table  
  val insertWith : (Val.t * Val.t -&gt; Val.t) -&gt; table * (Key.t * Val.t) -&gt; table  
  val delete : table * Key.t -&gt; table  
  
  val empty : unit -&gt; table  
  val singleton : Key.t * Val.t -&gt; table  
  val tabulate : (Key.t -&gt; Val.t) -&gt; Set.t -&gt; table  
  val fromSeq : (Key.t * Val.t) Seq.t -&gt; table  
  
  val map : (Val.t -&gt; Val.t) -&gt; table -&gt; table  
  val mapKey : (Key.t * Val.t -&gt; Val.t) -&gt; table -&gt; table  
  val filter : (Val.t -&gt; bool) -&gt; table -&gt; table  
  val filterKey : (Key.t * Val.t -&gt; bool) -&gt; table -&gt; table  
  
  val reduce : (Val.t * Val.t -&gt; Val.t) -&gt; Val.t -&gt; table -&gt; Val.t  
  val iterate : (&#39;a * Val.t -&gt; &#39;a) -&gt; &#39;a -&gt; table -&gt; &#39;a  
  
  val union : (Val.t * Val.t -&gt; Val.t) -&gt; table * table -&gt; table  
  val intersection : (Val.t * Val.t -&gt; Val.t) -&gt; table * table -&gt; table  
  val difference : table * table -&gt; table  
  
  val restrict : table * Set.t -&gt; table  
  val subtract : table * Set.t -&gt; table  
  
  val $ : (Key.t * Val.t) -&gt; table  
  
  (* ordered table functions *)  
  val first : table -&gt; (Key.t * Val.t) option  
  val last : table -&gt; (Key.t * Val.t) option  
  
  val prev : table * Key.t -&gt; (Key.t * Val.t) option  
  val next : table * Key.t -&gt; (Key.t * Val.t) option  
  
  val split : table * Key.t -&gt; table * Val.t option * table  
  val join : table * table -&gt; table  
  
  val getRange : table -&gt; Key.t * Key.t -&gt; table  
  
  val rank : table * Key.t -&gt; int  
  val select : table * int -&gt; (Key.t * Val.t) option  
  val splitRank : table * int -&gt; table * table  
  
  (* augmentation *)  
  val reduceVal : table -&gt; Val.t  
end  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
signature AUG_ORDTABLE =
sig
  structure Key : ORDKEY
  structure Val : MONOID
  structure Seq : SEQUENCE

  type t
  type table = t

  structure Set : ORDSET where Key = Key and Seq = Seq

  exception Order

  val size : table -> int
  val domain : table -> Set.t
  val range : table -> Val.t Seq.t
  val toString : table -> string
  val toSeq : table -> (Key.t * Val.t) Seq.t

  val find : table -> Key.t -> Val.t option
  val insert : table * (Key.t * Val.t) -> table
  val insertWith : (Val.t * Val.t -> Val.t) -> table * (Key.t * Val.t) -> table
  val delete : table * Key.t -> table

  val empty : unit -> table
  val singleton : Key.t * Val.t -> table
  val tabulate : (Key.t -> Val.t) -> Set.t -> table
  val fromSeq : (Key.t * Val.t) Seq.t -> table

  val map : (Val.t -> Val.t) -> table -> table
  val mapKey : (Key.t * Val.t -> Val.t) -> table -> table
  val filter : (Val.t -> bool) -> table -> table
  val filterKey : (Key.t * Val.t -> bool) -> table -> table

  val reduce : (Val.t * Val.t -> Val.t) -> Val.t -> table -> Val.t
  val iterate : ('a * Val.t -> 'a) -> 'a -> table -> 'a

  val union : (Val.t * Val.t -> Val.t) -> table * table -> table
  val intersection : (Val.t * Val.t -> Val.t) -> table * table -> table
  val difference : table * table -> table

  val restrict : table * Set.t -> table
  val subtract : table * Set.t -> table

  val $ : (Key.t * Val.t) -> table

  (* ordered table functions *)
  val first : table -> (Key.t * Val.t) option
  val last : table -> (Key.t * Val.t) option

  val prev : table * Key.t -> (Key.t * Val.t) option
  val next : table * Key.t -> (Key.t * Val.t) option

  val split : table * Key.t -> table * Val.t option * table
  val join : table * table -> table

  val getRange : table -> Key.t * Key.t -> table

  val rank : table * Key.t -> int
  val select : table * int -> (Key.t * Val.t) option
  val splitRank : table * int -> table * table

  (* augmentation *)
  val reduceVal : table -> Val.t
end
\end{verbatim}
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- subsection -->
<block name='subsection'>
<field name='title'>
<![CDATA[
Substructures
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Substructures
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
Key
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Key
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Key : ORDKEY  </code></pre>
<p>The <code>Key</code> substructure defines the type of keys in a table, which are totally ordered according to the provided comparison function.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Key : ORDKEY
\end{verbatim}
The \sml{Key} substructure defines the type of keys in a table, which are
totally ordered according to the provided comparison function.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
Val
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Val
]]>
</field> <!-- title_src -->
<field name='label'>
gr:aug-ordtable-interface:Val
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Val : MONOID  </code></pre>
<p>The <code>Val</code> substructure defines the type of values in a table, which ascribe to <a href="#gr:aug-ordtable-interface:MONOID" data-reference-type="ref" data-reference="gr:aug-ordtable-interface:MONOID">[gr:aug-ordtable-interface:MONOID]</a>, specifying how reduced values are computed.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Val : MONOID
\end{verbatim}
The \sml{Val} substructure defines the type of values in a table, which
ascribe to \ref{gr:aug-ordtable-interface:MONOID}, specifying how reduced
values are computed.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
Seq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Seq
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Seq : SEQUENCE  </code></pre>
<p>The <code>Seq</code> substructure defines the underlying sequence type, so that we may convert tables to and from sequences.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Seq : SEQUENCE
\end{verbatim}
The \sml{Seq} substructure defines the underlying sequence type, so that we
may convert tables to and from sequences.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
Set
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Set
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Set : ORDSET  </code></pre>
<p>The <code>Set</code> substructure contains operations on ordered sets with elements of type <code>Key.t</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Set : ORDSET
\end{verbatim}
The \sml{Set} substructure contains operations on ordered sets with elements of
type \sml{Key.t}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- subsection -->
<block name='subsection'>
<field name='title'>
<![CDATA[
Types
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Types
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>type t  
type table = t  </code></pre>
<p>The abstract table type with keys of type <code>Key.t</code> and values of type <code>Val.t</code>. The alias <code>table</code> is for readability in the signature.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
type t
type table = t
\end{verbatim}
The abstract table type with keys of type \sml{Key.t} and values of type
\sml{Val.t}. The alias \sml{table} is for readability in the signature.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- subsection -->
<block name='subsection'>
<field name='title'>
<![CDATA[
Exceptions
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Exceptions
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>exception Order  </code></pre>
<p><code>Order</code> is raised when the ordering invariant would be violated.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
exception Order
\end{verbatim}
\sml{Order} is raised when the ordering invariant would be violated.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- subsection -->
<block name='subsection'>
<field name='title'>
<![CDATA[
Values
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Values
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
size
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
size
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val size : table -&gt; int  </code></pre>
<p>The number of key-value pairs in a table.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val size : table -> int
\end{verbatim}
The number of key-value pairs in a table.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
domain
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
domain
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val domain : table -&gt; Set.t  </code></pre>
<p>Return the set of all keys in a table.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val domain : table -> Set.t
\end{verbatim}
Return the set of all keys in a table.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
range
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
range
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val range : table -&gt; Val.t Seq.t  </code></pre>
<p>Return a sequence of all values in a table. The order of the elements is implementation-defined.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val range : table -> Val.t Seq.t
\end{verbatim}
Return a sequence of all values in a table. The order of the elements is
implementation-defined.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toString
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toString
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toString : table -&gt; string  </code></pre>
<p><code>toString t</code> returns a string representation of <span class="math inline">\(t\)</span>. Each key is converted to a string via <code>Key.toString</code> and each value is converted via <code>Val.toString</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toString : table -> string
\end{verbatim}
\sml{toString t} returns a string representation of $t$. Each key is converted
to a string via \sml{Key.toString} and each value is converted via
\sml{Val.toString}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toSeq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toSeq
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toSeq : table -&gt; (Key.t * Val.t) Seq.t  </code></pre>
<p>Return a sequence of all key-value pairs in a table, sorted by key.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toSeq : table -> (Key.t * Val.t) Seq.t
\end{verbatim}
Return a sequence of all key-value pairs in a table, sorted by key.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
find
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
find
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val find : table -&gt; Key.t -&gt; Val.t option  </code></pre>
<p><code>find t k</code> returns <code>SOME v</code> if <span class="math inline">\((k \mapsto v) \in t\)</span>, and <code>NONE</code> otherwise.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val find : table -> Key.t -> Val.t option
\end{verbatim}
\sml{find t k} returns \sml{SOME v} if $(k \mapsto v) \in t$, and \sml{NONE}
otherwise.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
insert
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
insert
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val insert : table * (Key.t * Val.t) -&gt; table  </code></pre>
<p><code>insert (t, (k, v))</code> returns <span class="math inline">\(t \cup \{k \mapsto v\}\)</span>. If <span class="math inline">\(k\)</span> is already in <span class="math inline">\(t\)</span>, then the new value <span class="math inline">\(v\)</span> is given precedence. It is logically equivalent to <code>insertWith (fn (_, v) =&gt; v) (t, (k, v))</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val insert : table * (Key.t * Val.t) -> table
\end{verbatim}
\sml{insert (t, (k, v))} returns $t \cup \{k \mapsto v\}$. If $k$ is already
in $t$, then the new value $v$ is given precedence. It is logically equivalent
to \sml{insertWith (fn (\_, v) => v) (t, (k, v))}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
insertWith
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
insertWith
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val insertWith : (Val.t * Val.t -&gt; Val.t) -&gt; table * (Key.t * Val.t) -&gt; table  </code></pre>
<p><code>insertWith f (t, (k, v))</code> returns <span class="math inline">\(t \cup \{k \mapsto v\}\)</span> if <span class="math inline">\(k\)</span> is not already a member of <span class="math inline">\(t\)</span>, and otherwise it returns <span class="math inline">\(t \cup \{k \mapsto f(v&#39;,v)\}\)</span> where <span class="math inline">\(k \mapsto v&#39;\)</span> is already in <span class="math inline">\(t\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val insertWith : (Val.t * Val.t -> Val.t) -> table * (Key.t * Val.t) -> table
\end{verbatim}
\sml{insertWith f (t, (k, v))} returns $t \cup \{k \mapsto v\}$ if $k$ is not
already a member of $t$, and otherwise it returns $t \cup \{k \mapsto f(v',v)\}$
where $k \mapsto v'$ is already in $t$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
delete
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
delete
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val delete : table * Key.t -&gt; table  </code></pre>
<p><code>delete (t, k)</code> removes the key <span class="math inline">\(k\)</span> from <span class="math inline">\(t\)</span> only if <span class="math inline">\(k\)</span> is a member of <span class="math inline">\(t\)</span>. That is, if <span class="math inline">\((k \mapsto v) \in t\)</span> then it returns <span class="math inline">\(t \setminus \{(k \mapsto v)\}\)</span>, otherwise it returns <span class="math inline">\(t\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val delete : table * Key.t -> table
\end{verbatim}
\sml{delete (t, k)} removes the key $k$ from $t$ only if $k$ is a member of $t$.
That is, if $(k \mapsto v) \in t$ then it returns
$t \setminus \{(k \mapsto v)\}$, otherwise it returns $t$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
empty
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
empty
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val empty : unit -&gt; table  </code></pre>
<p>Construct the empty table.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val empty : unit -> table
\end{verbatim}
Construct the empty table.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
singleton
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
singleton
]]>
</field> <!-- title_src -->
<field name='label'>
gr:aug-ordtable-interface:singleton
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val singleton : Key.t * Val.t -&gt; table  </code></pre>
<p><code>singleton (k, v)</code> constructs the singleton table <span class="math inline">\(\{k \mapsto v\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val singleton : Key.t * Val.t -> table
\end{verbatim}
\sml{singleton (k, v)} constructs the singleton table $\{k \mapsto v\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
tabulate
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
tabulate
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val tabulate : (Key.t -&gt; Val.t) -&gt; Set.t -&gt; table  </code></pre>
<p><code>tabulate f s</code> evaluates to the table <span class="math inline">\(\{(k \mapsto f(k)) : k \in s\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val tabulate : (Key.t -> Val.t) -> Set.t -> table
\end{verbatim}
\sml{tabulate f s} evaluates to the table $\{(k \mapsto f(k)) : k \in s\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
fromSeq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
fromSeq
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val fromSeq : (Key.t * Val.t) Seq.t -&gt; table  </code></pre>
<p>Return the table representation of a sequence of key-value pairs. If there are duplicate keys, then it takes the value associated with the first occurence in the sequence.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val fromSeq : (Key.t * Val.t) Seq.t -> table
\end{verbatim}
Return the table representation of a sequence of key-value pairs. If there are
duplicate keys, then it takes the value associated with the first occurence in
the sequence.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
map
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
map
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val map : (Val.t -&gt; Val.t) -&gt; table -&gt; table  </code></pre>
<p><code>map f t</code> evaluates to <span class="math inline">\(\{k \mapsto f(v) : (k \mapsto v) \in t\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val map : (Val.t -> Val.t) -> table -> table
\end{verbatim}
\sml{map f t} evaluates to $\{k \mapsto f(v) : (k \mapsto v) \in t\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
mapKey
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
mapKey
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val mapKey : (Key.t * Val.t -&gt; Val.t) -&gt; table -&gt; table  </code></pre>
<p><code>mapKey f t</code> evaluates to <span class="math inline">\(\{k \mapsto f(k, v) : (k \mapsto v) \in t\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val mapKey : (Key.t * Val.t -> Val.t) -> table -> table
\end{verbatim}
\sml{mapKey f t} evaluates to $\{k \mapsto f(k, v) : (k \mapsto v) \in t\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
filter
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
filter
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val filter : (Val.t -&gt; bool) -&gt; table -&gt; table  </code></pre>
<p><code>filter p t</code> produces a table containing all <span class="math inline">\((k \mapsto v) \in t\)</span> which satisfies <span class="math inline">\(p(v)\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val filter : (Val.t -> bool) -> table -> table
\end{verbatim}
\sml{filter p t} produces a table containing all $(k \mapsto v) \in t$ which
satisfies $p(v)$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
filterKey
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
filterKey
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val filterKey : (Key.t * Val.t -&gt; bool) -&gt; table -&gt; table  </code></pre>
<p><code>filterKey p t</code> produces a table containing all <span class="math inline">\((k \mapsto v) \in t\)</span> which satisfies <span class="math inline">\(p(k,v)\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val filterKey : (Key.t * Val.t -> bool) -> table -> table
\end{verbatim}
\sml{filterKey p t} produces a table containing all $(k \mapsto v) \in t$ which
satisfies $p(k,v)$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
reduce
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
reduce
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val reduce : (Val.t * Val.t -&gt; Val.t) -&gt; Val.t -&gt; table -&gt; Val.t  </code></pre>
<p><code>reduce f b t</code> is logically equivalent to <code>Seq.reduce f b (range t)</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val reduce : (Val.t * Val.t -> Val.t) -> Val.t -> table -> Val.t
\end{verbatim}
\sml{reduce f b t} is logically equivalent to \sml{Seq.reduce f b (range t)}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
iterate
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
iterate
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val iterate : (&#39;a * Val.t -&gt; &#39;a) -&gt; &#39;a -&gt; table -&gt; &#39;a  </code></pre>
<p><code>iterate f b t</code> is logically equivalent to <code>Seq.iterate f b (range t)</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val iterate : ('a * Val.t -> 'a) -> 'a -> table -> 'a
\end{verbatim}
\sml{iterate f b t} is logically equivalent to \sml{Seq.iterate f b (range t)}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
union
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
union
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val union : (Val.t * Val.t -&gt; Val.t) -&gt; (table * table) -&gt; table  </code></pre>
<p><code>union f (a, b)</code> evaluates to <span class="math inline">\(a \cup b\)</span>. For keys <span class="math inline">\(k\)</span> where <span class="math inline">\((k \mapsto v) \in a\)</span> and <span class="math inline">\((k \mapsto w) \in b\)</span>, the result contains <span class="math inline">\(k \mapsto f(v,w)\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val union : (Val.t * Val.t -> Val.t) -> (table * table) -> table
\end{verbatim}
\sml{union f (a, b)} evaluates to $a \cup b$. For keys $k$ where $(k \mapsto v) \in a$
and $(k \mapsto w) \in b$, the result contains $k \mapsto f(v,w)$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
intersection
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
intersection
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val intersection : (Val.t * Val.t -&gt; Val.t) -&gt; table * table -&gt; table  </code></pre>
<p><code>intersection f (a, b)</code> evaluates to <span class="math inline">\(a \cap b\)</span>. Every intersecting key <span class="math inline">\(k\)</span> is mapped to <span class="math inline">\(f(v,w)\)</span> where <span class="math inline">\((k \mapsto v) \in a\)</span> and <span class="math inline">\((k \mapsto w) \in b\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val intersection : (Val.t * Val.t -> Val.t) -> table * table -> table
\end{verbatim}
\sml{intersection f (a, b)} evaluates to $a \cap b$. Every intersecting key
$k$ is mapped to $f(v,w)$ where $(k \mapsto v) \in a$ and $(k \mapsto w) \in b$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
difference
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
difference
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val difference : table * table -&gt; table  </code></pre>
<p><code>difference (a, b)</code> evaluates to <span class="math inline">\(a \setminus b\)</span>. The values in the output are taken from <span class="math inline">\(a\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val difference : table * table -> table
\end{verbatim}
\sml{difference (a, b)} evaluates to $a \setminus b$. The values in the output
are taken from $a$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
restrict
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
restrict
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val restrict : table * Set.t -&gt; table  </code></pre>
<p><code>restrict (t, s)</code> returns the table of <span class="math inline">\(\{(k \mapsto v) \in t \mathbin| k \in s\}\)</span>. It is therefore essentially an intersection. The name is motivated by the notion of restricting a function to a smaller domain, where we interpret a table as a function.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val restrict : table * Set.t -> table
\end{verbatim}
\sml{restrict (t, s)} returns the table of $\{(k \mapsto v) \in t \mathbin| k \in s\}$.
It is therefore essentially an intersection. The name is motivated by the
notion of restricting a function to a smaller domain, where we interpret a table
as a function.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
subtract
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
subtract
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val subtract : table * Set.t -&gt; table  </code></pre>
<p><code>subtract (t, s)</code> returns the table of <span class="math inline">\(\{(k \mapsto v) \in t \mathbin| k \not\in s\}\)</span>. The name is motivated by the notion of a domain subtraction on a function.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val subtract : table * Set.t -> table
\end{verbatim}
\sml{subtract (t, s)} returns the table of
$\{(k \mapsto v) \in t \mathbin| k \not\in s\}$.
The name is motivated by the notion of a domain subtraction on a function.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
$
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\$
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val $ : (Key.t * Val.t) -&gt; table  </code></pre>
<p>An alias for <a href="#gr:aug-ordtable-interface:singleton" data-reference-type="ref" data-reference="gr:aug-ordtable-interface:singleton">[gr:aug-ordtable-interface:singleton]</a>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val $ : (Key.t * Val.t) -> table
\end{verbatim}
An alias for \ref{gr:aug-ordtable-interface:singleton}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
first
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
first
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val first : table -&gt; (Key.t * Val.t) option  </code></pre>
<p>Return the smallest key (together with its associated value) of a table, or <code>NONE</code> if the table is empty.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val first : table -> (Key.t * Val.t) option
\end{verbatim}
Return the smallest key (together with its associated value) of a table, or
\sml{NONE} if the table is empty.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
last
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
last
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val last : table -&gt; (Key.t * Val.t) option  </code></pre>
<p>Return the largest key (together with its associated value) of a table, or <code>NONE</code> if the table is empty.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val last : table -> (Key.t * Val.t) option
\end{verbatim}
Return the largest key (together with its associated value) of a table, or
\sml{NONE} if the table is empty.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
prev
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
prev
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val prev : table * Key.t -&gt; (Key.t * Val.t) option  </code></pre>
<p><code>prev (t, k)</code> returns the largest key (together with its associated value) in <span class="math inline">\(t\)</span> which is strictly smaller than <span class="math inline">\(k\)</span>, or <code>NONE</code> if there is no such key.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val prev : table * Key.t -> (Key.t * Val.t) option
\end{verbatim}
\sml{prev (t, k)} returns the largest key (together with its associated value)
in $t$
which is strictly smaller than $k$, or \sml{NONE} if there is no such key.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
next
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
next
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val next : table * Key.t -&gt; (Key.t * Val.t) option  </code></pre>
<p><code>next (t, k)</code> returns the smallest key (together with its associated value) in <span class="math inline">\(t\)</span> which is strictly greater than <span class="math inline">\(k\)</span>, or <code>NONE</code> if there is no such key.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val next : table * Key.t -> (Key.t * Val.t) option
\end{verbatim}
\sml{next (t, k)} returns the smallest key (together with its associated value)
in $t$
which is strictly greater than $k$, or \sml{NONE} if there is no such key.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
split
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
split
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val split : table * Key.t -&gt; table * Val.t option * table  </code></pre>
<p><code>split (t, k)</code> evaluates to <span class="math inline">\((\ell, v, r)\)</span> where <span class="math inline">\(\ell\)</span> consists of all key-value pairs with keys strictly smaller than <span class="math inline">\(k\)</span>, <span class="math inline">\(r\)</span> consists of all key-value pairs with keys strictly greater than <span class="math inline">\(k\)</span>, and <span class="math inline">\(v\)</span> is <span class="math inline">\(k\)</span>’s associated value in <span class="math inline">\(t\)</span> (or <code>NONE</code> if <span class="math inline">\(k\)</span> is not present in <span class="math inline">\(t\)</span>).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val split : table * Key.t -> table * Val.t option * table
\end{verbatim}
\sml{split (t, k)} evaluates to $(\ell, v, r)$ where $\ell$ consists of all
key-value pairs with keys strictly smaller than $k$, $r$ consists of all key-value
pairs with keys strictly greater than $k$, and $v$ is $k$'s associated value
in $t$ (or \sml{NONE} if $k$ is not present in $t$).
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
join
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
join
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val join : table * table -&gt; table  </code></pre>
<p>Given tables <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> where all keys in <span class="math inline">\(a\)</span> are strictly smaller than all keys in <span class="math inline">\(b\)</span>, <code>join (a, b)</code> evaluates to <span class="math inline">\(a \cup b\)</span>. Otherwise, it raises <code>Order</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val join : table * table -> table
\end{verbatim}
Given tables $a$ and $b$ where all keys in $a$ are strictly smaller than all
keys in $b$, \sml{join (a, b)} evaluates to $a \cup b$. Otherwise, it raises
\sml{Order}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
getRange
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
getRange
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val getRange : table -&gt; Key.t * Key.t -&gt; table  </code></pre>
<p><code>getRange t (x, y)</code> evaluates to <span class="math inline">\(\{(k \mapsto v) \in t \mathbin| x \leq k \leq y\}\)</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val getRange : table -> Key.t * Key.t -> table
\end{verbatim}
\sml{getRange t (x, y)} evaluates to $\{(k \mapsto v) \in t \mathbin| x \leq k \leq y\}$
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
rank
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
rank
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val rank : table * Key.t -&gt; int  </code></pre>
<p><code>rank (t, k)</code> evaluates to the number of keys in <span class="math inline">\(t\)</span> which are strictly smaller than <span class="math inline">\(k\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val rank : table * Key.t -> int
\end{verbatim}
\sml{rank (t, k)} evaluates to the number of keys in $t$ which are strictly
smaller than $k$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
select
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
select
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val select : table * int -&gt; (Key.t * Val.t) option  </code></pre>
<p><code>select (t, i)</code> evaluates to the <span class="math inline">\(i^\text{th}\)</span> smallest key (and its associated value), or <code>NONE</code> if either <span class="math inline">\(i &lt; 0\)</span> or <span class="math inline">\(i \geq |t|\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val select : table * int -> (Key.t * Val.t) option
\end{verbatim}
\sml{select (t, i)} evaluates to the $i^\text{th}$ smallest key (and its
associated value), or \sml{NONE} if either $i < 0$ or $i \geq |t|$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
splitRank
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
splitRank
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val splitRank : table * int -&gt; table * table  </code></pre>
<p><code>splitRank (t, i)</code> evalutes to <span class="math inline">\((\ell,r)\)</span> where <span class="math inline">\(\ell\)</span> consists of the <span class="math inline">\(i\)</span> keys of <span class="math inline">\(t\)</span>, and <span class="math inline">\(r\)</span> is the set of the <span class="math inline">\(|t|-i\)</span> largest keys of <span class="math inline">\(t\)</span>. Raises <code>Fail</code> if either <span class="math inline">\(i &lt; 0\)</span> or <span class="math inline">\(i \geq |t|\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val splitRank : table * int -> table * table
\end{verbatim}
\sml{splitRank (t, i)} evalutes to $(\ell,r)$ where $\ell$ consists of the $i$
keys of $t$, and $r$ is the set of the $|t|-i$ largest
keys of $t$. Raises \sml{Fail} if either $i < 0$ or $i \geq |t|$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
reduceVal
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
reduceVal
]]>
</field> <!-- title_src -->
<field name='label'>
gr:aug-ordtable-interface:reduceVal
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val reduceVal : table -&gt; Val.t  </code></pre>
<p><code>reduceVal t</code> is logically equivalent to <code>Seq.reduce Val.f Val.I (range t)</code>. See <a href="#gr:aug-ordtable-interface:MONOID" data-reference-type="ref" data-reference="gr:aug-ordtable-interface:MONOID">[gr:aug-ordtable-interface:MONOID]</a> below for more information.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val reduceVal : table -> Val.t
\end{verbatim}
\sml{reduceVal t} is logically equivalent to
\sml{Seq.reduce Val.f Val.I (range t)}. See
\ref{gr:aug-ordtable-interface:MONOID} below for more information.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- subsection -->

</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Reduced Values as Monoids
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Reduced Values as Monoids
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->

<block name='subsection'>
<field name='title'>
<![CDATA[
Summary
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Summary
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The value type of an augmented ordered table ascribes to <code>MONOID</code>, which specifies an abstract type <span class="math inline">\(t\)</span> together with an identity <span class="math inline">\(I\)</span>, an <em>associative</em> combination function <span class="math inline">\(f\)</span>, and a <code>toString</code> function for convenience. The reduced value of a table is given by “summing” all values in the table, with respect to <span class="math inline">\(f\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The value type of an augmented ordered table ascribes to \sml{MONOID}, which
specifies an abstract type $t$ together with an identity $I$, an
\emph{associative} combination function $f$, and a \sml{toString} function for
convenience. The reduced value of a table is given by ``summing'' all values in
the table, with respect to $f$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
MONOID
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
MONOID
]]>
</field> <!-- title_src -->
<field name='label'>
gr:aug-ordtable-interface:MONOID
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>signature MONOID =  
sig  
  type t  
  val I : t  
  val f : t * t -&gt; t  
  val toString : t -&gt; string  
end  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
signature MONOID =
sig
  type t
  val I : t
  val f : t * t -> t
  val toString : t -> string
end
\end{verbatim}
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- subsection -->
<block name='subsection'>
<field name='title'>
<![CDATA[
Types and Values
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Types and Values
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>type t  </code></pre>
<p>The abstract type of the monoid.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
type t
\end{verbatim}
The abstract type of the monoid.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
I
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
I
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val I : t  </code></pre>
<p>The identity of the monoid. Must satisfy <span class="math inline">\(f(I, x) = x = f(x, I)\)</span> for all monoid elements <span class="math inline">\(x\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val I : t
\end{verbatim}
The identity of the monoid. Must satisfy $f(I, x) = x = f(x, I)$ for all
monoid elements $x$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
f
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
f
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val f : t * t -&gt; t  </code></pre>
<p>The associative combination function of the monoid.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val f : t * t -> t
\end{verbatim}
The associative combination function of the monoid.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toString
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toString
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toString : t -&gt; string  </code></pre>
<p>Return a string representation.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toString : t -> string
\end{verbatim}
Return a string representation.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- subsection -->

</block> <!-- section -->

</block> <!-- chapter -->
