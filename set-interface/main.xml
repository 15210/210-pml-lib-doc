<?xml version="1.0" encoding="UTF-8"?>
<block name='chapter'>
<field name='title'>
<![CDATA[
Set Interface
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Set Interface
]]>
</field> <!-- title_src -->
<field name='label'>
ch:set-interface
</field> <!-- label -->
<atom name='preamble'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>SET</code> interface specifies an unordered collection of items. Sets do not contain duplicates, and are not polymorphic: the type of their elements is given by the <code>Key</code> substructure.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{SET} interface specifies an unordered collection of items. Sets do not
contain duplicates, and are not polymorphic: the type of their elements is
given by the \sml{Key} substructure.
]]>
</field> <!-- body_src -->
</atom> <!-- preamble -->

<block name='section'>
<field name='title'>
<![CDATA[
Summary
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Summary
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>signature SET =  
sig  
  structure Key : EQKEY  
  structure Seq : SEQUENCE  
  
  type t  
  type set = t  
  
  val size : set -&gt; int  
  val toString : set -&gt; string  
  val toSeq : set -&gt; Key.t Seq.t  
  
  val empty : unit -&gt; set  
  val singleton : Key.t -&gt; set  
  val fromSeq : Key.t Seq.t -&gt; set  
  
  val find : set -&gt; Key.t -&gt; bool  
  val insert : set * Key.t -&gt; set  
  val delete : set * Key.t -&gt; set  
  
  val filterKey : (Key.t -&gt; bool) -&gt; set -&gt; set  
  
  val reduceKey : (Key.t * Key.t -&gt; Key.t) -&gt; Key.t -&gt; set -&gt; Key.t  
  val iterateKey : (&#39;a * Key.t -&gt; &#39;a) -&gt; &#39;a -&gt; set -&gt; &#39;a  
  
  val union : set * set -&gt; set  
  val intersection : set * set -&gt; set  
  val difference : set * set -&gt; set  
  
  val $ : Key.t -&gt; set  
end  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
signature SET =
sig
  structure Key : EQKEY
  structure Seq : SEQUENCE

  type t
  type set = t

  val size : set -> int
  val toString : set -> string
  val toSeq : set -> Key.t Seq.t

  val empty : unit -> set
  val singleton : Key.t -> set
  val fromSeq : Key.t Seq.t -> set

  val find : set -> Key.t -> bool
  val insert : set * Key.t -> set
  val delete : set * Key.t -> set

  val filterKey : (Key.t -> bool) -> set -> set

  val reduceKey : (Key.t * Key.t -> Key.t) -> Key.t -> set -> Key.t
  val iterateKey : ('a * Key.t -> 'a) -> 'a -> set -> 'a

  val union : set * set -> set
  val intersection : set * set -> set
  val difference : set * set -> set

  val $ : Key.t -> set
end
\end{verbatim}
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Substructures
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Substructures
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Key : EQKEY  </code></pre>
<p>The <code>Key</code> substructure defines the type of elements in a set, which may be compared for equality.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Key : EQKEY
\end{verbatim}
The \sml{Key} substructure defines the type of elements in a set, which may be
compared for equality.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Seq : SEQUENCE  </code></pre>
<p>The <code>Seq</code> substructure defines the underlying sequence type, so that we may convert sets to and from sequences.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Seq : SEQUENCE
\end{verbatim}
The \sml{Seq} substructure defines the underlying sequence type, so that we
may convert sets to and from sequences.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Types
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Types
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>type t  
type set = t  </code></pre>
<p>The abstract set type. The alias <code>set</code> is for readability in the signature.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
type t
type set = t
\end{verbatim}
The abstract set type. The alias \sml{set} is for readability in the
signature.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Values
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Values
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
size
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
size
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val size : set -&gt; int  </code></pre>
<p>The number of elements in a set.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val size : set -> int
\end{verbatim}
The number of elements in a set.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toString
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toString
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toString : set -&gt; string  </code></pre>
<p>Evaluates to a string representation of the set. Each element is converted to a string via <code>Key.toString</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toString : set -> string
\end{verbatim}
Evaluates to a string representation of the set. Each element is converted to
a string via \sml{Key.toString}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toSeq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toSeq
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toSeq : set -&gt; Key.t Seq.t  </code></pre>
<p>Return a sequence of all keys in a set. The ordering of the elements in the returned sequence is implementation-defined.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toSeq : set -> Key.t Seq.t
\end{verbatim}
Return a sequence of all keys in a set. The ordering of the elements in the
returned sequence is implementation-defined.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
empty
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
empty
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val empty : unit -&gt; set  </code></pre>
<p>Construct the empty set.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val empty : unit -> set
\end{verbatim}
Construct the empty set.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
singleton
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
singleton
]]>
</field> <!-- title_src -->
<field name='label'>
gr:set-interface:singleton
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val singleton : Key.t -&gt; set  </code></pre>
<p>Construct the singleton set containing only the provided key.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val singleton : Key.t -> set
\end{verbatim}
Construct the singleton set containing only the provided key.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
fromSeq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
fromSeq
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val fromSeq : Key.t Seq.t -&gt; set  </code></pre>
<p>Return the set of all elements of a sequence.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val fromSeq : Key.t Seq.t -> set
\end{verbatim}
Return the set of all elements of a sequence.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
find
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
find
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val find : set -&gt; Key.t -&gt; bool  </code></pre>
<p><code>find s k</code> returns whether or not <span class="math inline">\(k\)</span> is a member of the set <span class="math inline">\(s\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val find : set -> Key.t -> bool
\end{verbatim}
\sml{find s k} returns whether or not $k$ is a member of the set $s$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
insert
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
insert
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val insert : set * Key.t -&gt; set  </code></pre>
<p><code>insert (s, k)</code> evaluates to the set <span class="math inline">\(s \cup \{k\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val insert : set * Key.t -> set
\end{verbatim}
\sml{insert (s, k)} evaluates to the set $s \cup \{k\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
delete
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
delete
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val delete : set * Key.t -&gt; set  </code></pre>
<p><code>delete (s, k)</code> evaluates to the set <span class="math inline">\(s \setminus \{k\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val delete : set * Key.t -> set
\end{verbatim}
\sml{delete (s, k)} evaluates to the set $s \setminus \{k\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
filterKey
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
filterKey
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val filterKey : (Key.t -&gt; bool) -&gt; set -&gt; set  </code></pre>
<p><code>filterKey p s</code> evaluates to the set <span class="math inline">\(\{x \in s \mathbin| p(x) \}\)</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val filterKey : (Key.t -> bool) -> set -> set
\end{verbatim}
\sml{filterKey p s} evaluates to the set $\{x \in s \mathbin| p(x) \}$
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
reduceKey
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
reduceKey
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val reduceKey : (Key.t * Key.t -&gt; Key.t) -&gt; Key.t -&gt; set -&gt; Key.t  </code></pre>
<p><code>reduceKey f b s</code> is logically equivalent to <code>Seq.reduce f b (toSeq s)</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val reduceKey : (Key.t * Key.t -> Key.t) -> Key.t -> set -> Key.t
\end{verbatim}
\sml{reduceKey f b s} is logically equivalent to \sml{Seq.reduce f b (toSeq s)}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
iterateKey
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
iterateKey
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val iterateKey : (&#39;a * Key.t -&gt; &#39;a) -&gt; &#39;a -&gt; set -&gt; &#39;a  </code></pre>
<p><code>iterateKey f b s</code> is logically equivalent to <code>Seq.iterate f b (toSeq s)</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val iterateKey : ('a * Key.t -> 'a) -> 'a -> set -> 'a
\end{verbatim}
\sml{iterateKey f b s} is logically equivalent to \sml{Seq.iterate f b (toSeq s)}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
union
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
union
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val union : set * set -&gt; set  </code></pre>
<p><code>union a b</code> evaluates to the set <span class="math inline">\(a \cup b\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val union : set * set -> set
\end{verbatim}
\sml{union a b} evaluates to the set $a \cup b$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
intersection
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
intersection
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val intersection : set * set -&gt; set  </code></pre>
<p><code>intersection a b</code> evaluates to the set <span class="math inline">\(a \cap b\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val intersection : set * set -> set
\end{verbatim}
\sml{intersection a b} evaluates to the set $a \cap b$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
difference
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
difference
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val difference : set * set -&gt; set  </code></pre>
<p><code>difference a b</code> evaluates to the set <span class="math inline">\(a \setminus b\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val difference : set * set -> set
\end{verbatim}
\sml{difference a b} evaluates to the set $a \setminus b$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
$
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\$
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val $ : Key.t -&gt; set  </code></pre>
<p>An alias for <a href="#gr:set-interface:singleton" data-reference-type="ref" data-reference="gr:set-interface:singleton">[gr:set-interface:singleton]</a>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val $ : Key.t -> set
\end{verbatim}
An alias for \ref{gr:set-interface:singleton}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->

</block> <!-- chapter -->
