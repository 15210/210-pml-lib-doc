<?xml version="1.0" encoding="UTF-8"?>
<block name='chapter'>
<field name='title'>
<![CDATA[
OrdTable Interface
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
OrdTable Interface
]]>
</field> <!-- title_src -->
<field name='label'>
ch:ordtable-interface
</field> <!-- label -->
<atom name='preamble'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>ORDTABLE</code> interface specifies a mapping from keys to values, written <span class="math inline">\(\{k_1 \mapsto v_1, k_2 \mapsto v_2, \ldots\}\)</span>. Tables do not have duplicate keys, so there is a unique associated value for each key in the domain of a table. The key type is given by the <code>Key</code> substructure, and the value type is polymorphic.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{ORDTABLE} interface specifies a mapping from keys to values, written
$\{k_1 \mapsto v_1, k_2 \mapsto v_2, \ldots\}$. Tables do not have duplicate
keys, so there is a unique associated value for each key in the domain of
a table. The key type is given by the \sml{Key} substructure, and the value
type is polymorphic.
]]>
</field> <!-- body_src -->
</atom> <!-- preamble -->
<atom name='note'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>ORDTABLE</code> signature is identical to <code>TABLE</code> except for the following.</p>
<ul>
<li><p>The <code>Key</code> substructure now ascribes to <code>ORDKEY</code>.</p></li>
<li><p>There is additional functionality relying upon the ordering of keys, such as <code>split</code>, <code>join</code>, and <code>getRange</code>.</p></li>
<li><p>The <code>toSeq</code> function now specifies that it returns keys in sorted order.</p></li>
</ul>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{ORDTABLE} signature is identical to \sml{TABLE} except for the following.
\begin{itemize}
  \item The \sml{Key} substructure now ascribes to \sml{ORDKEY}.
  \item There is additional functionality relying upon the ordering of keys,
  such as \sml{split}, \sml{join}, and \sml{getRange}.
  \item The \sml{toSeq} function now specifies that it returns keys in sorted order.
\end{itemize}
]]>
</field> <!-- body_src -->
</atom> <!-- note -->

<block name='section'>
<field name='title'>
<![CDATA[
Summary
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Summary
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>signature ORDTABLE =  
sig  
  structure Key : ORDKEY  
  structure Seq : SEQUENCE  
  
  type &#39;a t  
  type &#39;a table = &#39;a t  
  
  structure Set : ORDSET where Key = Key and Seq = Seq  
  
  exception Order  
  
  val size : &#39;a table -&gt; int  
  val domain : &#39;a table -&gt; Set.t  
  val range : &#39;a table -&gt; &#39;a Seq.t  
  val toString : (&#39;a -&gt; string) -&gt; &#39;a table -&gt; string  
  val toSeq : &#39;a table -&gt; (Key.t * &#39;a) Seq.t  
  
  val find : &#39;a table -&gt; Key.t -&gt; &#39;a option  
  val insert : &#39;a table * (Key.t * &#39;a) -&gt; &#39;a table  
  val insertWith : (&#39;a * &#39;a -&gt; &#39;a) -&gt; &#39;a table * (Key.t * &#39;a) -&gt; &#39;a table  
  val delete : &#39;a table * Key.t -&gt; &#39;a table  
  
  val empty : unit -&gt; &#39;a table  
  val singleton : Key.t * &#39;a -&gt; &#39;a table  
  val tabulate : (Key.t -&gt; &#39;a) -&gt; Set.t -&gt; &#39;a table  
  val collect : (Key.t * &#39;a) Seq.t -&gt; &#39;a Seq.t table  
  val fromSeq : (Key.t * &#39;a) Seq.t -&gt; &#39;a table  
  
  val map : (&#39;a -&gt; &#39;b) -&gt; &#39;a table -&gt; &#39;b table  
  val mapKey : (Key.t * &#39;a -&gt; &#39;b) -&gt; &#39;a table -&gt; &#39;b table  
  val filter : (&#39;a -&gt; bool) -&gt; &#39;a table -&gt; &#39;a table  
  val filterKey : (Key.t * &#39;a -&gt; bool) -&gt; &#39;a table -&gt; &#39;a table  
  
  val reduce : (&#39;a * &#39;a -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;a table -&gt; &#39;a  
  val iterate : (&#39;b * &#39;a -&gt; &#39;b) -&gt; &#39;b -&gt; &#39;a table -&gt; &#39;b  
  val iteratePrefixes : (&#39;b * &#39;a -&gt; &#39;b) -&gt; &#39;b -&gt; &#39;a table -&gt; (&#39;b table * &#39;b)  
  
  val union : (&#39;a * &#39;a -&gt; &#39;a) -&gt; (&#39;a table * &#39;a table) -&gt; &#39;a table  
  val intersection : (&#39;a * &#39;b -&gt; &#39;c) -&gt; &#39;a table * &#39;b table -&gt; &#39;c table  
  val difference : &#39;a table * &#39;b table -&gt; &#39;a table  
  
  val restrict : &#39;a table * Set.t -&gt; &#39;a table  
  val subtract : &#39;a table * Set.t -&gt; &#39;a table  
  
  val $ : (Key.t * &#39;a) -&gt; &#39;a table  
  
  (* ordered tables begins here *)  
  val first : &#39;a table -&gt; (Key.t * &#39;a) option  
  val last : &#39;a table -&gt; (Key.t * &#39;a) option  
  
  val prev : &#39;a table * Key.t -&gt; (Key.t * &#39;a) option  
  val next : &#39;a table * Key.t -&gt; (Key.t * &#39;a) option  
  
  val split : &#39;a table * Key.t -&gt; &#39;a table * &#39;a option * &#39;a table  
  val join : &#39;a table * &#39;a table -&gt; &#39;a table  
  
  val getRange : &#39;a table -&gt; Key.t * Key.t -&gt; &#39;a table  
  
  val rank : &#39;a table * Key.t -&gt; int  
  val select : &#39;a table * int -&gt; (Key.t * &#39;a) option  
  val splitRank : &#39;a table * int -&gt; &#39;a table * &#39;a table  
end  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
signature ORDTABLE =
sig
  structure Key : ORDKEY
  structure Seq : SEQUENCE

  type 'a t
  type 'a table = 'a t

  structure Set : ORDSET where Key = Key and Seq = Seq

  exception Order

  val size : 'a table -> int
  val domain : 'a table -> Set.t
  val range : 'a table -> 'a Seq.t
  val toString : ('a -> string) -> 'a table -> string
  val toSeq : 'a table -> (Key.t * 'a) Seq.t

  val find : 'a table -> Key.t -> 'a option
  val insert : 'a table * (Key.t * 'a) -> 'a table
  val insertWith : ('a * 'a -> 'a) -> 'a table * (Key.t * 'a) -> 'a table
  val delete : 'a table * Key.t -> 'a table

  val empty : unit -> 'a table
  val singleton : Key.t * 'a -> 'a table
  val tabulate : (Key.t -> 'a) -> Set.t -> 'a table
  val collect : (Key.t * 'a) Seq.t -> 'a Seq.t table
  val fromSeq : (Key.t * 'a) Seq.t -> 'a table

  val map : ('a -> 'b) -> 'a table -> 'b table
  val mapKey : (Key.t * 'a -> 'b) -> 'a table -> 'b table
  val filter : ('a -> bool) -> 'a table -> 'a table
  val filterKey : (Key.t * 'a -> bool) -> 'a table -> 'a table

  val reduce : ('a * 'a -> 'a) -> 'a -> 'a table -> 'a
  val iterate : ('b * 'a -> 'b) -> 'b -> 'a table -> 'b
  val iteratePrefixes : ('b * 'a -> 'b) -> 'b -> 'a table -> ('b table * 'b)

  val union : ('a * 'a -> 'a) -> ('a table * 'a table) -> 'a table
  val intersection : ('a * 'b -> 'c) -> 'a table * 'b table -> 'c table
  val difference : 'a table * 'b table -> 'a table

  val restrict : 'a table * Set.t -> 'a table
  val subtract : 'a table * Set.t -> 'a table

  val $ : (Key.t * 'a) -> 'a table

  (* ordered tables begins here *)
  val first : 'a table -> (Key.t * 'a) option
  val last : 'a table -> (Key.t * 'a) option

  val prev : 'a table * Key.t -> (Key.t * 'a) option
  val next : 'a table * Key.t -> (Key.t * 'a) option

  val split : 'a table * Key.t -> 'a table * 'a option * 'a table
  val join : 'a table * 'a table -> 'a table

  val getRange : 'a table -> Key.t * Key.t -> 'a table

  val rank : 'a table * Key.t -> int
  val select : 'a table * int -> (Key.t * 'a) option
  val splitRank : 'a table * int -> 'a table * 'a table
end
\end{verbatim}
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Substructures
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Substructures
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Key : ORDKEY  </code></pre>
<p>The <code>Key</code> substructure defines the type of keys in a table, which are totally ordered according to the provided comparison function.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Key : ORDKEY
\end{verbatim}
The \sml{Key} substructure defines the type of keys in a table, which are
totally ordered according to the provided comparison function.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Seq : SEQUENCE  </code></pre>
<p>The <code>Seq</code> substructure defines the underlying sequence type, so that we may convert tables to and from sequences.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Seq : SEQUENCE
\end{verbatim}
The \sml{Seq} substructure defines the underlying sequence type, so that we
may convert tables to and from sequences.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Set : ORDSET  </code></pre>
<p>The <code>Set</code> substructure contains operations on ordered sets with elements of type <code>Key.t</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Set : ORDSET
\end{verbatim}
The \sml{Set} substructure contains operations on ordered sets with elements of
type \sml{Key.t}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Types
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Types
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>type &#39;a t  
type &#39;a table = &#39;a t  </code></pre>
<p>The abstract table type with values of type <code>’a</code>. The alias <code>table</code> is for readability in the signature.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
type 'a t
type 'a table = 'a t
\end{verbatim}
The abstract table type with values of type \sml{'a}. The alias \sml{table} is
for readability in the signature.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Exceptions
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Exceptions
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>exception Order  </code></pre>
<p><code>Order</code> is raised when the ordering invariant would be violated.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
exception Order
\end{verbatim}
\sml{Order} is raised when the ordering invariant would be violated.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Values
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Values
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
size
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
size
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val size : &#39;a table -&gt; int  </code></pre>
<p>The number of key-value pairs in a table.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val size : 'a table -> int
\end{verbatim}
The number of key-value pairs in a table.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
domain
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
domain
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val domain : &#39;a table -&gt; Set.t  </code></pre>
<p>Return the set of all keys in a table.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val domain : 'a table -> Set.t
\end{verbatim}
Return the set of all keys in a table.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
range
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
range
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val range : &#39;a table -&gt; &#39;a Seq.t  </code></pre>
<p>Return a sequence of all values in a table. The order of the elements is implementation-defined.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val range : 'a table -> 'a Seq.t
\end{verbatim}
Return a sequence of all values in a table. The order of the elements is
implementation-defined.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toString
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toString
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toString : (&#39;a -&gt; string) -&gt; &#39;a table -&gt; string  </code></pre>
<p><code>toString f t</code> returns a string representation of <span class="math inline">\(t\)</span>. Each key is converted to a string via <code>Key.toString</code> and each value is converted via <span class="math inline">\(f\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toString : ('a -> string) -> 'a table -> string
\end{verbatim}
\sml{toString f t} returns a string representation of $t$. Each key is converted
to a string via \sml{Key.toString} and each value is converted via $f$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toSeq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toSeq
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toSeq : &#39;a table -&gt; (Key.t * &#39;a) Seq.t  </code></pre>
<p>Return a sequence of all key-value pairs in a table, sorted by key.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toSeq : 'a table -> (Key.t * 'a) Seq.t
\end{verbatim}
Return a sequence of all key-value pairs in a table, sorted by key.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
find
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
find
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val find : &#39;a table -&gt; Key.t -&gt; &#39;a option  </code></pre>
<p><code>find t k</code> returns <code>SOME v</code> if <span class="math inline">\((k \mapsto v) \in t\)</span>, and <code>NONE</code> otherwise.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val find : 'a table -> Key.t -> 'a option
\end{verbatim}
\sml{find t k} returns \sml{SOME v} if $(k \mapsto v) \in t$, and \sml{NONE}
otherwise.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
insert
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
insert
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val insert : &#39;a table * (Key.t * &#39;a) -&gt; &#39;a table  </code></pre>
<p><code>insert (t, (k, v))</code> returns <span class="math inline">\(t \cup \{k \mapsto v\}\)</span>. If <span class="math inline">\(k\)</span> is already in <span class="math inline">\(t\)</span>, then the new value <span class="math inline">\(v\)</span> is given precedence. It is logically equivalent to <code>insertWith (fn (_, v) =&gt; v) (t, (k, v))</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val insert : 'a table * (Key.t * 'a) -> 'a table
\end{verbatim}
\sml{insert (t, (k, v))} returns $t \cup \{k \mapsto v\}$. If $k$ is already
in $t$, then the new value $v$ is given precedence. It is logically equivalent
to \sml{insertWith (fn (\_, v) => v) (t, (k, v))}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
insertWith
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
insertWith
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val insertWith : (&#39;a * &#39;a -&gt; &#39;a) -&gt; &#39;a table * (Key.t * &#39;a) -&gt; &#39;a table  </code></pre>
<p><code>insertWith f (t, (k, v))</code> returns <span class="math inline">\(t \cup \{k \mapsto v\}\)</span> if <span class="math inline">\(k\)</span> is not already a member of <span class="math inline">\(t\)</span>, and otherwise it returns <span class="math inline">\(t \cup \{k \mapsto f(v&#39;,v)\}\)</span> where <span class="math inline">\(k \mapsto v&#39;\)</span> is already in <span class="math inline">\(t\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val insertWith : ('a * 'a -> 'a) -> 'a table * (Key.t * 'a) -> 'a table
\end{verbatim}
\sml{insertWith f (t, (k, v))} returns $t \cup \{k \mapsto v\}$ if $k$ is not
already a member of $t$, and otherwise it returns $t \cup \{k \mapsto f(v',v)\}$
where $k \mapsto v'$ is already in $t$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
delete
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
delete
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val delete : &#39;a table * Key.t -&gt; &#39;a table  </code></pre>
<p><code>delete (t, k)</code> removes the key <span class="math inline">\(k\)</span> from <span class="math inline">\(t\)</span> only if <span class="math inline">\(k\)</span> is a member of <span class="math inline">\(t\)</span>. That is, if <span class="math inline">\((k \mapsto v) \in t\)</span> then it returns <span class="math inline">\(t \setminus \{(k \mapsto v)\}\)</span>, otherwise it returns <span class="math inline">\(t\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val delete : 'a table * Key.t -> 'a table
\end{verbatim}
\sml{delete (t, k)} removes the key $k$ from $t$ only if $k$ is a member of $t$.
That is, if $(k \mapsto v) \in t$ then it returns
$t \setminus \{(k \mapsto v)\}$, otherwise it returns $t$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
empty
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
empty
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val empty : unit -&gt; &#39;a table  </code></pre>
<p>Construct the empty table.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val empty : unit -> 'a table
\end{verbatim}
Construct the empty table.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
singleton
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
singleton
]]>
</field> <!-- title_src -->
<field name='label'>
gr:ordtable-interface:singleton
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val singleton : Key.t * &#39;a -&gt; &#39;a table  </code></pre>
<p><code>singleton (k, v)</code> constructs the singleton table <span class="math inline">\(\{k \mapsto v\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val singleton : Key.t * 'a -> 'a table
\end{verbatim}
\sml{singleton (k, v)} constructs the singleton table $\{k \mapsto v\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
tabulate
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
tabulate
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val tabulate : (Key.t -&gt; &#39;a) -&gt; Set.t -&gt; &#39;a table  </code></pre>
<p><code>tabulate f s</code> evaluates to the table <span class="math inline">\(\{(k \mapsto f(k)) : k \in s\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val tabulate : (Key.t -> 'a) -> Set.t -> 'a table
\end{verbatim}
\sml{tabulate f s} evaluates to the table $\{(k \mapsto f(k)) : k \in s\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
collect
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
collect
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val collect : (Key.t * &#39;a) Seq.t -&gt; &#39;a Seq.t table  </code></pre>
<p><code>collect s</code> takes a sequence of key-value pairs and produces a table where each unique key <span class="math inline">\(k\)</span> is paired with <span class="math inline">\(\langle v : (k&#39;,v) \in s \mathbin| k&#39; = k \rangle\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val collect : (Key.t * 'a) Seq.t -> 'a Seq.t table
\end{verbatim}
\sml{collect s} takes a sequence of key-value pairs and produces a table where
each unique key $k$ is paired with
$\langle v : (k',v) \in s \mathbin| k' = k \rangle$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
fromSeq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
fromSeq
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val fromSeq : (Key.t * &#39;a) Seq.t -&gt; &#39;a table  </code></pre>
<p>Return the table representation of a sequence of key-value pairs. If there are duplicate keys, then it takes the value associated with the first occurence in the sequence.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val fromSeq : (Key.t * 'a) Seq.t -> 'a table
\end{verbatim}
Return the table representation of a sequence of key-value pairs. If there are
duplicate keys, then it takes the value associated with the first occurence in
the sequence.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
map
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
map
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val map : (&#39;a -&gt; &#39;b) -&gt; &#39;a table -&gt; &#39;b table  </code></pre>
<p><code>map f t</code> evaluates to <span class="math inline">\(\{k \mapsto f(v) : (k \mapsto v) \in t\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val map : ('a -> 'b) -> 'a table -> 'b table
\end{verbatim}
\sml{map f t} evaluates to $\{k \mapsto f(v) : (k \mapsto v) \in t\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
mapKey
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
mapKey
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val mapKey : (Key.t * &#39;a -&gt; &#39;b) -&gt; &#39;a table -&gt; &#39;b table  </code></pre>
<p><code>mapKey f t</code> evaluates to <span class="math inline">\(\{k \mapsto f(k, v) : (k \mapsto v) \in t\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val mapKey : (Key.t * 'a -> 'b) -> 'a table -> 'b table
\end{verbatim}
\sml{mapKey f t} evaluates to $\{k \mapsto f(k, v) : (k \mapsto v) \in t\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
filter
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
filter
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val filter : (&#39;a -&gt; bool) -&gt; &#39;a table -&gt; &#39;a table  </code></pre>
<p><code>filter p t</code> produces a table containing all <span class="math inline">\((k \mapsto v) \in t\)</span> which satisfies <span class="math inline">\(p(v)\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val filter : ('a -> bool) -> 'a table -> 'a table
\end{verbatim}
\sml{filter p t} produces a table containing all $(k \mapsto v) \in t$ which
satisfies $p(v)$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
filterKey
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
filterKey
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val filterKey : (Key.t * &#39;a -&gt; bool) -&gt; &#39;a table -&gt; &#39;a table  </code></pre>
<p><code>filterKey p t</code> produces a table containing all <span class="math inline">\((k \mapsto v) \in t\)</span> which satisfies <span class="math inline">\(p(k,v)\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val filterKey : (Key.t * 'a -> bool) -> 'a table -> 'a table
\end{verbatim}
\sml{filterKey p t} produces a table containing all $(k \mapsto v) \in t$ which
satisfies $p(k,v)$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
reduce
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
reduce
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val reduce : (&#39;a * &#39;a -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;a table -&gt; &#39;a  </code></pre>
<p><code>reduce f b t</code> is logically equivalent to <code>Seq.reduce f b (range t)</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val reduce : ('a * 'a -> 'a) -> 'a -> 'a table -> 'a
\end{verbatim}
\sml{reduce f b t} is logically equivalent to \sml{Seq.reduce f b (range t)}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
iterate
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
iterate
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val iterate : (&#39;b * &#39;a -&gt; &#39;b) -&gt; &#39;b -&gt; &#39;a table -&gt; &#39;b  </code></pre>
<p><code>iterate f b t</code> is logically equivalent to <code>Seq.iterate f b (range t)</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val iterate : ('b * 'a -> 'b) -> 'b -> 'a table -> 'b
\end{verbatim}
\sml{iterate f b t} is logically equivalent to \sml{Seq.iterate f b (range t)}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
iteratePrefixes
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
iteratePrefixes
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val iteratePrefixes : (&#39;b * &#39;a -&gt; &#39;b) -&gt; &#39;b -&gt; &#39;a table -&gt; (&#39;b table * &#39;b)  </code></pre>
<p><code>iteratePrefixes f b t</code> is logically equivalent to <code>(fromSeq p, x)</code> where <code>(p,x) = Seq.iteratePrefixes f b (range t)</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val iteratePrefixes : ('b * 'a -> 'b) -> 'b -> 'a table -> ('b table * 'b)
\end{verbatim}
\sml{iteratePrefixes f b t} is logically equivalent to
\sml{(fromSeq p, x)} where \sml{(p,x) = Seq.iteratePrefixes f b (range t)}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
union
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
union
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val union : (&#39;a * &#39;a -&gt; &#39;a) -&gt; (&#39;a table * &#39;a table) -&gt; &#39;a table  </code></pre>
<p><code>union f (a, b)</code> evaluates to <span class="math inline">\(a \cup b\)</span>. For keys <span class="math inline">\(k\)</span> where <span class="math inline">\((k \mapsto v) \in a\)</span> and <span class="math inline">\((k \mapsto w) \in b\)</span>, the result contains <span class="math inline">\(k \mapsto f(v,w)\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val union : ('a * 'a -> 'a) -> ('a table * 'a table) -> 'a table
\end{verbatim}
\sml{union f (a, b)} evaluates to $a \cup b$. For keys $k$ where $(k \mapsto v) \in a$
and $(k \mapsto w) \in b$, the result contains $k \mapsto f(v,w)$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
intersection
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
intersection
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val intersection : (&#39;a * &#39;b -&gt; &#39;c) -&gt; &#39;a table * &#39;b table -&gt; &#39;c table  </code></pre>
<p><code>intersection f (a, b)</code> evaluates to <span class="math inline">\(a \cap b\)</span>. Every intersecting key <span class="math inline">\(k\)</span> is mapped to <span class="math inline">\(f(v,w)\)</span> where <span class="math inline">\((k \mapsto v) \in a\)</span> and <span class="math inline">\((k \mapsto w) \in b\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val intersection : ('a * 'b -> 'c) -> 'a table * 'b table -> 'c table
\end{verbatim}
\sml{intersection f (a, b)} evaluates to $a \cap b$. Every intersecting key
$k$ is mapped to $f(v,w)$ where $(k \mapsto v) \in a$ and $(k \mapsto w) \in b$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
difference
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
difference
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val difference : &#39;a table * &#39;b table -&gt; &#39;a table  </code></pre>
<p><code>difference (a, b)</code> evaluates to <span class="math inline">\(a \setminus b\)</span>. The values in the output are taken from <span class="math inline">\(a\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val difference : 'a table * 'b table -> 'a table
\end{verbatim}
\sml{difference (a, b)} evaluates to $a \setminus b$. The values in the output
are taken from $a$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
restrict
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
restrict
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val restrict : &#39;a table * Set.t -&gt; &#39;a table  </code></pre>
<p><code>restrict (t, s)</code> returns the table of <span class="math inline">\(\{(k \mapsto v) \in t \mathbin| k \in s\}\)</span>. It is therefore essentially an intersection. The name is motivated by the notion of restricting a function to a smaller domain, where we interpret a table as a function.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val restrict : 'a table * Set.t -> 'a table
\end{verbatim}
\sml{restrict (t, s)} returns the table of $\{(k \mapsto v) \in t \mathbin| k \in s\}$.
It is therefore essentially an intersection. The name is motivated by the
notion of restricting a function to a smaller domain, where we interpret a table
as a function.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
subtract
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
subtract
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val subtract : &#39;a table * Set.t -&gt; &#39;a table  </code></pre>
<p><code>subtract (t, s)</code> returns the table of <span class="math inline">\(\{(k \mapsto v) \in t \mathbin| k \not\in s\}\)</span>. The name is motivated by the notion of a domain subtraction on a function.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val subtract : 'a table * Set.t -> 'a table
\end{verbatim}
\sml{subtract (t, s)} returns the table of
$\{(k \mapsto v) \in t \mathbin| k \not\in s\}$.
The name is motivated by the notion of a domain subtraction on a function.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
$
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\$
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val $ : (Key.t * &#39;a) -&gt; &#39;a table  </code></pre>
<p>An alias for <a href="#gr:ordtable-interface:singleton" data-reference-type="ref" data-reference="gr:ordtable-interface:singleton">[gr:ordtable-interface:singleton]</a>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val $ : (Key.t * 'a) -> 'a table
\end{verbatim}
An alias for \ref{gr:ordtable-interface:singleton}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
first
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
first
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val first : &#39;a table -&gt; (Key.t * &#39;a) option  </code></pre>
<p>Return the smallest key (together with its associated value) of a table, or <code>NONE</code> if the table is empty.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val first : 'a table -> (Key.t * 'a) option
\end{verbatim}
Return the smallest key (together with its associated value) of a table, or
\sml{NONE} if the table is empty.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
last
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
last
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val last : &#39;a table -&gt; (Key.t * &#39;a) option  </code></pre>
<p>Return the largest key (together with its associated value) of a table, or <code>NONE</code> if the table is empty.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val last : 'a table -> (Key.t * 'a) option
\end{verbatim}
Return the largest key (together with its associated value) of a table, or
\sml{NONE} if the table is empty.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
prev
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
prev
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val prev : &#39;a table * Key.t -&gt; (Key.t * &#39;a) option  </code></pre>
<p><code>prev (t, k)</code> returns the largest key (together with its associated value) in <span class="math inline">\(t\)</span> which is strictly smaller than <span class="math inline">\(k\)</span>, or <code>NONE</code> if there is no such key.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val prev : 'a table * Key.t -> (Key.t * 'a) option
\end{verbatim}
\sml{prev (t, k)} returns the largest key (together with its associated value)
in $t$
which is strictly smaller than $k$, or \sml{NONE} if there is no such key.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
next
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
next
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val next : &#39;a table * Key.t -&gt; (Key.t * &#39;a) option  </code></pre>
<p><code>next (t, k)</code> returns the smallest key (together with its associated value) in <span class="math inline">\(t\)</span> which is strictly greater than <span class="math inline">\(k\)</span>, or <code>NONE</code> if there is no such key.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val next : 'a table * Key.t -> (Key.t * 'a) option
\end{verbatim}
\sml{next (t, k)} returns the smallest key (together with its associated value)
in $t$
which is strictly greater than $k$, or \sml{NONE} if there is no such key.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
split
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
split
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val split : &#39;a table * Key.t -&gt; &#39;a table * &#39;a option * &#39;a table  </code></pre>
<p><code>split (t, k)</code> evaluates to <span class="math inline">\((\ell, v, r)\)</span> where <span class="math inline">\(\ell\)</span> consists of all key-value pairs with keys strictly smaller than <span class="math inline">\(k\)</span>, <span class="math inline">\(r\)</span> consists of all key-value pairs with keys strictly greater than <span class="math inline">\(k\)</span>, and <span class="math inline">\(v\)</span> is <span class="math inline">\(k\)</span>’s associated value in <span class="math inline">\(t\)</span> (or <code>NONE</code> if <span class="math inline">\(k\)</span> is not present in <span class="math inline">\(t\)</span>).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val split : 'a table * Key.t -> 'a table * 'a option * 'a table
\end{verbatim}
\sml{split (t, k)} evaluates to $(\ell, v, r)$ where $\ell$ consists of all
key-value pairs with keys strictly smaller than $k$, $r$ consists of all key-value
pairs with keys strictly greater than $k$, and $v$ is $k$'s associated value
in $t$ (or \sml{NONE} if $k$ is not present in $t$).
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
join
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
join
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val join : &#39;a table * &#39;a table -&gt; &#39;a table  </code></pre>
<p>Given tables <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> where all keys in <span class="math inline">\(a\)</span> are strictly smaller than all keys in <span class="math inline">\(b\)</span>, <code>join (a, b)</code> evaluates to <span class="math inline">\(a \cup b\)</span>. Otherwise, it raises <code>Order</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val join : 'a table * 'a table -> 'a table
\end{verbatim}
Given tables $a$ and $b$ where all keys in $a$ are strictly smaller than all
keys in $b$, \sml{join (a, b)} evaluates to $a \cup b$. Otherwise, it raises
\sml{Order}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
getRange
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
getRange
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val getRange : &#39;a table -&gt; Key.t * Key.t -&gt; &#39;a table  </code></pre>
<p><code>getRange t (x, y)</code> evaluates to <span class="math inline">\(\{(k \mapsto v) \in t \mathbin| x \leq k \leq y\}\)</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val getRange : 'a table -> Key.t * Key.t -> 'a table
\end{verbatim}
\sml{getRange t (x, y)} evaluates to $\{(k \mapsto v) \in t \mathbin| x \leq k \leq y\}$
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
rank
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
rank
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val rank : &#39;a table * Key.t -&gt; int  </code></pre>
<p><code>rank (t, k)</code> evaluates to the number of keys in <span class="math inline">\(t\)</span> which are strictly smaller than <span class="math inline">\(k\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val rank : 'a table * Key.t -> int
\end{verbatim}
\sml{rank (t, k)} evaluates to the number of keys in $t$ which are strictly
smaller than $k$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
select
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
select
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val select : &#39;a table * int -&gt; (Key.t * &#39;a) option  </code></pre>
<p><code>select (t, i)</code> evaluates to the <span class="math inline">\(i^\text{th}\)</span> smallest key (and its associated value), or <code>NONE</code> if either <span class="math inline">\(i &lt; 0\)</span> or <span class="math inline">\(i \geq |t|\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val select : 'a table * int -> (Key.t * 'a) option
\end{verbatim}
\sml{select (t, i)} evaluates to the $i^\text{th}$ smallest key (and its
associated value), or \sml{NONE} if either $i < 0$ or $i \geq |t|$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
splitRank
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
splitRank
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val splitRank : &#39;a table * int -&gt; &#39;a table * &#39;a table  </code></pre>
<p><code>splitRank (t, i)</code> evalutes to <span class="math inline">\((\ell,r)\)</span> where <span class="math inline">\(\ell\)</span> consists of the <span class="math inline">\(i\)</span> keys of <span class="math inline">\(t\)</span>, and <span class="math inline">\(r\)</span> is the set of the <span class="math inline">\(|t|-i\)</span> largest keys of <span class="math inline">\(t\)</span>. Raises <code>Fail</code> if either <span class="math inline">\(i &lt; 0\)</span> or <span class="math inline">\(i \geq |t|\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val splitRank : 'a table * int -> 'a table * 'a table
\end{verbatim}
\sml{splitRank (t, i)} evalutes to $(\ell,r)$ where $\ell$ consists of the $i$
keys of $t$, and $r$ is the set of the $|t|-i$ largest
keys of $t$. Raises \sml{Fail} if either $i < 0$ or $i \geq |t|$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->

</block> <!-- chapter -->
