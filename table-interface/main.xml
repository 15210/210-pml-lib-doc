<?xml version="1.0" encoding="UTF-8"?>
<block name='chapter'>
<field name='title'>
<![CDATA[
Table Interface
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Table Interface
]]>
</field> <!-- title_src -->
<field name='label'>
ch:table-interface
</field> <!-- label -->
<atom name='preamble'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>TABLE</code> interface specifies a mapping from keys to values, written <span class="math inline">\(\{k_1 \mapsto v_1, k_2 \mapsto v_2, \ldots\}\)</span>. Tables do not have duplicate keys, so there is a unique associated value for each key in the domain of a table. The key type is given by the <code>Key</code> substructure, and the value type is polymorphic.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{TABLE} interface specifies a mapping from keys to values, written
$\{k_1 \mapsto v_1, k_2 \mapsto v_2, \ldots\}$. Tables do not have duplicate
keys, so there is a unique associated value for each key in the domain of
a table. The key type is given by the \sml{Key} substructure, and the value
type is polymorphic.
]]>
</field> <!-- body_src -->
</atom> <!-- preamble -->

<block name='section'>
<field name='title'>
<![CDATA[
Summary
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Summary
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>signature TABLE =  
sig  
  structure Key : EQKEY  
  structure Seq : SEQUENCE  
  
  type &#39;a t  
  type &#39;a table = &#39;a t  
  
  structure Set : SET where Key = Key and Seq = Seq  
  
  val size : &#39;a table -&gt; int  
  val domain : &#39;a table -&gt; Set.t  
  val range : &#39;a table -&gt; &#39;a Seq.t  
  val toString : (&#39;a -&gt; string) -&gt; &#39;a table -&gt; string  
  val toSeq : &#39;a table -&gt; (Key.t * &#39;a) Seq.t  
  
  val find : &#39;a table -&gt; Key.t -&gt; &#39;a option  
  val insert : &#39;a table * (Key.t * &#39;a) -&gt; &#39;a table  
  val insertWith : (&#39;a * &#39;a -&gt; &#39;a) -&gt; &#39;a table * (Key.t * &#39;a) -&gt; &#39;a table  
  val delete : &#39;a table * Key.t -&gt; &#39;a table  
  
  val empty : unit -&gt; &#39;a table  
  val singleton : Key.t * &#39;a -&gt; &#39;a table  
  val tabulate : (Key.t -&gt; &#39;a) -&gt; Set.t -&gt; &#39;a table  
  val collect : (Key.t * &#39;a) Seq.t -&gt; &#39;a Seq.t table  
  val fromSeq : (Key.t * &#39;a) Seq.t -&gt; &#39;a table  
  
  val map : (&#39;a -&gt; &#39;b) -&gt; &#39;a table -&gt; &#39;b table  
  val mapKey : (Key.t * &#39;a -&gt; &#39;b) -&gt; &#39;a table -&gt; &#39;b table  
  val filter : (&#39;a -&gt; bool) -&gt; &#39;a table -&gt; &#39;a table  
  val filterKey : (Key.t * &#39;a -&gt; bool) -&gt; &#39;a table -&gt; &#39;a table  
  
  val reduce : (&#39;a * &#39;a -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;a table -&gt; &#39;a  
  val iterate : (&#39;b * &#39;a -&gt; &#39;b) -&gt; &#39;b -&gt; &#39;a table -&gt; &#39;b  
  val iteratePrefixes : (&#39;b * &#39;a -&gt; &#39;b) -&gt; &#39;b -&gt; &#39;a table -&gt; (&#39;b table * &#39;b)  
  
  val union : (&#39;a * &#39;a -&gt; &#39;a) -&gt; (&#39;a table * &#39;a table) -&gt; &#39;a table  
  val intersection : (&#39;a * &#39;b -&gt; &#39;c) -&gt; &#39;a table * &#39;b table -&gt; &#39;c table  
  val difference : &#39;a table * &#39;b table -&gt; &#39;a table  
  
  val restrict : &#39;a table * Set.t -&gt; &#39;a table  
  val subtract : &#39;a table * Set.t -&gt; &#39;a table  
  
  val $ : (Key.t * &#39;a) -&gt; &#39;a table  
end  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
signature TABLE =
sig
  structure Key : EQKEY
  structure Seq : SEQUENCE

  type 'a t
  type 'a table = 'a t

  structure Set : SET where Key = Key and Seq = Seq

  val size : 'a table -> int
  val domain : 'a table -> Set.t
  val range : 'a table -> 'a Seq.t
  val toString : ('a -> string) -> 'a table -> string
  val toSeq : 'a table -> (Key.t * 'a) Seq.t

  val find : 'a table -> Key.t -> 'a option
  val insert : 'a table * (Key.t * 'a) -> 'a table
  val insertWith : ('a * 'a -> 'a) -> 'a table * (Key.t * 'a) -> 'a table
  val delete : 'a table * Key.t -> 'a table

  val empty : unit -> 'a table
  val singleton : Key.t * 'a -> 'a table
  val tabulate : (Key.t -> 'a) -> Set.t -> 'a table
  val collect : (Key.t * 'a) Seq.t -> 'a Seq.t table
  val fromSeq : (Key.t * 'a) Seq.t -> 'a table

  val map : ('a -> 'b) -> 'a table -> 'b table
  val mapKey : (Key.t * 'a -> 'b) -> 'a table -> 'b table
  val filter : ('a -> bool) -> 'a table -> 'a table
  val filterKey : (Key.t * 'a -> bool) -> 'a table -> 'a table

  val reduce : ('a * 'a -> 'a) -> 'a -> 'a table -> 'a
  val iterate : ('b * 'a -> 'b) -> 'b -> 'a table -> 'b
  val iteratePrefixes : ('b * 'a -> 'b) -> 'b -> 'a table -> ('b table * 'b)

  val union : ('a * 'a -> 'a) -> ('a table * 'a table) -> 'a table
  val intersection : ('a * 'b -> 'c) -> 'a table * 'b table -> 'c table
  val difference : 'a table * 'b table -> 'a table

  val restrict : 'a table * Set.t -> 'a table
  val subtract : 'a table * Set.t -> 'a table

  val $ : (Key.t * 'a) -> 'a table
end
\end{verbatim}
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Substructures
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Substructures
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Key : EQKEY  </code></pre>
<p>The <code>Key</code> substructure defines the type of keys in a table, which may be compared for equality.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Key : EQKEY
\end{verbatim}
The \sml{Key} substructure defines the type of keys in a table, which may be
compared for equality.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Seq : SEQUENCE  </code></pre>
<p>The <code>Seq</code> substructure defines the underlying sequence type, so that we may convert tables to and from sequences.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Seq : SEQUENCE
\end{verbatim}
The \sml{Seq} substructure defines the underlying sequence type, so that we
may convert tables to and from sequences.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Set : SET  </code></pre>
<p>The <code>Set</code> substructure contains operations on sets with elements of type <code>Key.t</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Set : SET
\end{verbatim}
The \sml{Set} substructure contains operations on sets with elements of type
\sml{Key.t}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Types
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Types
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>type &#39;a t  
type &#39;a table = &#39;a t  </code></pre>
<p>The abstract table type with values of type <code>â€™a</code>. The alias <code>table</code> is for readability in the signature.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
type 'a t
type 'a table = 'a t
\end{verbatim}
The abstract table type with values of type \sml{'a}. The alias \sml{table} is
for readability in the signature.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Values
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Values
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
size
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
size
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val size : &#39;a table -&gt; int  </code></pre>
<p>The number of key-value pairs in a table.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val size : 'a table -> int
\end{verbatim}
The number of key-value pairs in a table.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
domain
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
domain
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val domain : &#39;a table -&gt; Set.t  </code></pre>
<p>Return the set of all keys in a table.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val domain : 'a table -> Set.t
\end{verbatim}
Return the set of all keys in a table.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
range
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
range
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val range : &#39;a table -&gt; &#39;a Seq.t  </code></pre>
<p>Return a sequence of all values in a table. The order of the elements is implementation-defined.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val range : 'a table -> 'a Seq.t
\end{verbatim}
Return a sequence of all values in a table. The order of the elements is
implementation-defined.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toString
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toString
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toString : (&#39;a -&gt; string) -&gt; &#39;a table -&gt; string  </code></pre>
<p><code>toString f t</code> returns a string representation of <span class="math inline">\(t\)</span>. Each key is converted to a string via <code>Key.toString</code> and each value is converted via <span class="math inline">\(f\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toString : ('a -> string) -> 'a table -> string
\end{verbatim}
\sml{toString f t} returns a string representation of $t$. Each key is converted
to a string via \sml{Key.toString} and each value is converted via $f$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toSeq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toSeq
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toSeq : &#39;a table -&gt; (Key.t * &#39;a) Seq.t  </code></pre>
<p>Return a sequence of all key-value pairs in a table. The order of the sequence is implementation-defined.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toSeq : 'a table -> (Key.t * 'a) Seq.t
\end{verbatim}
Return a sequence of all key-value pairs in a table. The order of the sequence
is implementation-defined.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
find
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
find
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val find : &#39;a table -&gt; Key.t -&gt; &#39;a option  </code></pre>
<p><code>find t k</code> returns <code>SOME v</code> if <span class="math inline">\((k \mapsto v) \in t\)</span>, and <code>NONE</code> otherwise.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val find : 'a table -> Key.t -> 'a option
\end{verbatim}
\sml{find t k} returns \sml{SOME v} if $(k \mapsto v) \in t$, and \sml{NONE}
otherwise.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
insert
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
insert
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val insert : &#39;a table * (Key.t * &#39;a) -&gt; &#39;a table  </code></pre>
<p><code>insert (t, (k, v))</code> returns <span class="math inline">\(t \cup \{k \mapsto v\}\)</span>. If <span class="math inline">\(k\)</span> is already in <span class="math inline">\(t\)</span>, then the new value <span class="math inline">\(v\)</span> is given precedence. It is logically equivalent to <code>insertWith (fn (_, v) =&gt; v) (t, (k, v))</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val insert : 'a table * (Key.t * 'a) -> 'a table
\end{verbatim}
\sml{insert (t, (k, v))} returns $t \cup \{k \mapsto v\}$. If $k$ is already
in $t$, then the new value $v$ is given precedence. It is logically equivalent
to \sml{insertWith (fn (\_, v) => v) (t, (k, v))}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
insertWith
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
insertWith
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val insertWith : (&#39;a * &#39;a -&gt; &#39;a) -&gt; &#39;a table * (Key.t * &#39;a) -&gt; &#39;a table  </code></pre>
<p><code>insertWith f (t, (k, v))</code> returns <span class="math inline">\(t \cup \{k \mapsto v\}\)</span> if <span class="math inline">\(k\)</span> is not already a member of <span class="math inline">\(t\)</span>, and otherwise it returns <span class="math inline">\(t \cup \{k \mapsto f(v&#39;,v)\}\)</span> where <span class="math inline">\(k \mapsto v&#39;\)</span> is already in <span class="math inline">\(t\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val insertWith : ('a * 'a -> 'a) -> 'a table * (Key.t * 'a) -> 'a table
\end{verbatim}
\sml{insertWith f (t, (k, v))} returns $t \cup \{k \mapsto v\}$ if $k$ is not
already a member of $t$, and otherwise it returns $t \cup \{k \mapsto f(v',v)\}$
where $k \mapsto v'$ is already in $t$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
delete
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
delete
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val delete : &#39;a table * Key.t -&gt; &#39;a table  </code></pre>
<p><code>delete (t, k)</code> removes the key <span class="math inline">\(k\)</span> from <span class="math inline">\(t\)</span> only if <span class="math inline">\(k\)</span> is a member of <span class="math inline">\(t\)</span>. That is, if <span class="math inline">\((k \mapsto v) \in t\)</span> then it returns <span class="math inline">\(t \setminus \{(k \mapsto v)\}\)</span>, otherwise it returns <span class="math inline">\(t\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val delete : 'a table * Key.t -> 'a table
\end{verbatim}
\sml{delete (t, k)} removes the key $k$ from $t$ only if $k$ is a member of $t$.
That is, if $(k \mapsto v) \in t$ then it returns
$t \setminus \{(k \mapsto v)\}$, otherwise it returns $t$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
empty
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
empty
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val empty : unit -&gt; &#39;a table  </code></pre>
<p>Construct the empty table.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val empty : unit -> 'a table
\end{verbatim}
Construct the empty table.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
singleton
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
singleton
]]>
</field> <!-- title_src -->
<field name='label'>
gr:table-interface:singleton
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val singleton : Key.t * &#39;a -&gt; &#39;a table  </code></pre>
<p><code>singleton (k, v)</code> constructs the singleton table <span class="math inline">\(\{k \mapsto v\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val singleton : Key.t * 'a -> 'a table
\end{verbatim}
\sml{singleton (k, v)} constructs the singleton table $\{k \mapsto v\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
tabulate
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
tabulate
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val tabulate : (Key.t -&gt; &#39;a) -&gt; Set.t -&gt; &#39;a table  </code></pre>
<p><code>tabulate f s</code> evaluates to the table <span class="math inline">\(\{(k \mapsto f(k)) : k \in s\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val tabulate : (Key.t -> 'a) -> Set.t -> 'a table
\end{verbatim}
\sml{tabulate f s} evaluates to the table $\{(k \mapsto f(k)) : k \in s\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
collect
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
collect
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val collect : (Key.t * &#39;a) Seq.t -&gt; &#39;a Seq.t table  </code></pre>
<p><code>collect s</code> takes a sequence of key-value pairs and produces a table where each unique key <span class="math inline">\(k\)</span> is paired with <span class="math inline">\(\langle v : (k&#39;,v) \in s \mathbin| k&#39; = k \rangle\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val collect : (Key.t * 'a) Seq.t -> 'a Seq.t table
\end{verbatim}
\sml{collect s} takes a sequence of key-value pairs and produces a table where
each unique key $k$ is paired with
$\langle v : (k',v) \in s \mathbin| k' = k \rangle$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
fromSeq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
fromSeq
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val fromSeq : (Key.t * &#39;a) Seq.t -&gt; &#39;a table  </code></pre>
<p>Return the table representation of a sequence of key-value pairs. If there are duplicate keys, then it takes the value associated with the first occurence in the sequence.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val fromSeq : (Key.t * 'a) Seq.t -> 'a table
\end{verbatim}
Return the table representation of a sequence of key-value pairs. If there are
duplicate keys, then it takes the value associated with the first occurence in
the sequence.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
map
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
map
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val map : (&#39;a -&gt; &#39;b) -&gt; &#39;a table -&gt; &#39;b table  </code></pre>
<p><code>map f t</code> evaluates to <span class="math inline">\(\{k \mapsto f(v) : (k \mapsto v) \in t\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val map : ('a -> 'b) -> 'a table -> 'b table
\end{verbatim}
\sml{map f t} evaluates to $\{k \mapsto f(v) : (k \mapsto v) \in t\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
mapKey
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
mapKey
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val mapKey : (Key.t * &#39;a -&gt; &#39;b) -&gt; &#39;a table -&gt; &#39;b table  </code></pre>
<p><code>mapKey f t</code> evaluates to <span class="math inline">\(\{k \mapsto f(k, v) : (k \mapsto v) \in t\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val mapKey : (Key.t * 'a -> 'b) -> 'a table -> 'b table
\end{verbatim}
\sml{mapKey f t} evaluates to $\{k \mapsto f(k, v) : (k \mapsto v) \in t\}$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
filter
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
filter
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val filter : (&#39;a -&gt; bool) -&gt; &#39;a table -&gt; &#39;a table  </code></pre>
<p><code>filter p t</code> produces a table containing all <span class="math inline">\((k \mapsto v) \in t\)</span> which satisfies <span class="math inline">\(p(v)\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val filter : ('a -> bool) -> 'a table -> 'a table
\end{verbatim}
\sml{filter p t} produces a table containing all $(k \mapsto v) \in t$ which
satisfies $p(v)$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
filterKey
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
filterKey
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val filterKey : (Key.t * &#39;a -&gt; bool) -&gt; &#39;a table -&gt; &#39;a table  </code></pre>
<p><code>filterKey p t</code> produces a table containing all <span class="math inline">\((k \mapsto v) \in t\)</span> which satisfies <span class="math inline">\(p(k,v)\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val filterKey : (Key.t * 'a -> bool) -> 'a table -> 'a table
\end{verbatim}
\sml{filterKey p t} produces a table containing all $(k \mapsto v) \in t$ which
satisfies $p(k,v)$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
reduce
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
reduce
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val reduce : (&#39;a * &#39;a -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;a table -&gt; &#39;a  </code></pre>
<p><code>reduce f b t</code> is logically equivalent to <code>Seq.reduce f b (range t)</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val reduce : ('a * 'a -> 'a) -> 'a -> 'a table -> 'a
\end{verbatim}
\sml{reduce f b t} is logically equivalent to \sml{Seq.reduce f b (range t)}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
iterate
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
iterate
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val iterate : (&#39;b * &#39;a -&gt; &#39;b) -&gt; &#39;b -&gt; &#39;a table -&gt; &#39;b  </code></pre>
<p><code>iterate f b t</code> is logically equivalent to <code>Seq.iterate f b (range t)</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val iterate : ('b * 'a -> 'b) -> 'b -> 'a table -> 'b
\end{verbatim}
\sml{iterate f b t} is logically equivalent to \sml{Seq.iterate f b (range t)}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
iteratePrefixes
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
iteratePrefixes
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val iteratePrefixes : (&#39;b * &#39;a -&gt; &#39;b) -&gt; &#39;b -&gt; &#39;a table -&gt; (&#39;b table * &#39;b)  </code></pre>
<p><code>iteratePrefixes f b t</code> is logically equivalent to <code>(fromSeq p, x)</code> where <code>(p,x) = Seq.iteratePrefixes f b (range t)</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val iteratePrefixes : ('b * 'a -> 'b) -> 'b -> 'a table -> ('b table * 'b)
\end{verbatim}
\sml{iteratePrefixes f b t} is logically equivalent to
\sml{(fromSeq p, x)} where \sml{(p,x) = Seq.iteratePrefixes f b (range t)}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
union
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
union
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val union : (&#39;a * &#39;a -&gt; &#39;a) -&gt; (&#39;a table * &#39;a table) -&gt; &#39;a table  </code></pre>
<p><code>union f (a, b)</code> evaluates to <span class="math inline">\(a \cup b\)</span>. For keys <span class="math inline">\(k\)</span> where <span class="math inline">\((k \mapsto v) \in a\)</span> and <span class="math inline">\((k \mapsto w) \in b\)</span>, the result contains <span class="math inline">\(k \mapsto f(v,w)\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val union : ('a * 'a -> 'a) -> ('a table * 'a table) -> 'a table
\end{verbatim}
\sml{union f (a, b)} evaluates to $a \cup b$. For keys $k$ where $(k \mapsto v) \in a$
and $(k \mapsto w) \in b$, the result contains $k \mapsto f(v,w)$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
intersection
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
intersection
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val intersection : (&#39;a * &#39;b -&gt; &#39;c) -&gt; &#39;a table * &#39;b table -&gt; &#39;c table  </code></pre>
<p><code>intersection f (a, b)</code> evaluates to <span class="math inline">\(a \cap b\)</span>. Every intersecting key <span class="math inline">\(k\)</span> is mapped to <span class="math inline">\(f(v,w)\)</span> where <span class="math inline">\((k \mapsto v) \in a\)</span> and <span class="math inline">\((k \mapsto w) \in b\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val intersection : ('a * 'b -> 'c) -> 'a table * 'b table -> 'c table
\end{verbatim}
\sml{intersection f (a, b)} evaluates to $a \cap b$. Every intersecting key
$k$ is mapped to $f(v,w)$ where $(k \mapsto v) \in a$ and $(k \mapsto w) \in b$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
difference
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
difference
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val difference : &#39;a table * &#39;b table -&gt; &#39;a table  </code></pre>
<p><code>difference (a, b)</code> evaluates to <span class="math inline">\(a \setminus b\)</span>. The values in the output are taken from <span class="math inline">\(a\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val difference : 'a table * 'b table -> 'a table
\end{verbatim}
\sml{difference (a, b)} evaluates to $a \setminus b$. The values in the output
are taken from $a$.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
restrict
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
restrict
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val restrict : &#39;a table * Set.t -&gt; &#39;a table  </code></pre>
<p><code>restrict (t, s)</code> returns the table of <span class="math inline">\(\{(k \mapsto v) \in t \mathbin| k \in s\}\)</span>. It is therefore essentially an intersection. The name is motivated by the notion of restricting a function to a smaller domain, where we interpret a table as a function.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val restrict : 'a table * Set.t -> 'a table
\end{verbatim}
\sml{restrict (t, s)} returns the table of $\{(k \mapsto v) \in t \mathbin| k \in s\}$.
It is therefore essentially an intersection. The name is motivated by the
notion of restricting a function to a smaller domain, where we interpret a table
as a function.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
subtract
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
subtract
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val subtract : &#39;a table * Set.t -&gt; &#39;a table  </code></pre>
<p><code>subtract (t, s)</code> returns the table of <span class="math inline">\(\{(k \mapsto v) \in t \mathbin| k \not\in s\}\)</span>. The name is motivated by the notion of a domain subtraction on a function.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val subtract : 'a table * Set.t -> 'a table
\end{verbatim}
\sml{subtract (t, s)} returns the table of
$\{(k \mapsto v) \in t \mathbin| k \not\in s\}$.
The name is motivated by the notion of a domain subtraction on a function.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
$
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\$
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val $ : (Key.t * &#39;a) -&gt; &#39;a table  </code></pre>
<p>An alias for <a href="#gr:table-interface:singleton" data-reference-type="ref" data-reference="gr:table-interface:singleton">[gr:table-interface:singleton]</a>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val $ : (Key.t * 'a) -> 'a table
\end{verbatim}
An alias for \ref{gr:table-interface:singleton}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->

</block> <!-- chapter -->
