<?xml version="1.0" encoding="UTF-8"?>
<block name='chapter'>
<field name='title'>
<![CDATA[
Single-Threaded Sequence Interface
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Single-Threaded Sequence Interface
]]>
</field> <!-- title_src -->
<field name='label'>
ch:st-seq-interface
</field> <!-- label -->
<atom name='preamble'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>ST_SEQUENCE</code> signature is a minimalistic interface for a single-threaded sequence type. Single-threaded sequences differ from normal sequences in that they are only meant to be used in a single-threaded manner: updates should only be made on a “most recent” version. However, operations on single-threaded sequences are always well-defined, regardless of context.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{ST\_SEQUENCE} signature is a minimalistic interface for a
single-threaded sequence type. Single-threaded sequences differ from normal
sequences in that they are only meant to be used in a single-threaded
manner: updates should only be made on a ``most recent'' version. However,
operations on single-threaded sequences are always well-defined, regardless of
context.
]]>
</field> <!-- body_src -->
</atom> <!-- preamble -->

<block name='section'>
<field name='title'>
<![CDATA[
Summary
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Summary
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>signature ST_SEQUENCE =  
sig  
  structure Seq : SEQUENCE  
  
  type &#39;a t  
  type &#39;a stseq = &#39;a t  
  
  exception Range  
  
  val fromSeq : &#39;a Seq.t -&gt; &#39;a stseq  
  val toSeq : &#39;a stseq -&gt; &#39;a Seq.t  
  val nth : &#39;a stseq -&gt; int -&gt; &#39;a  
  
  val update : (&#39;a stseq * (int * &#39;a)) -&gt; &#39;a stseq  
  val inject : (&#39;a stseq * (int * &#39;a) Seq.t) -&gt; &#39;a stseq  
end  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
signature ST_SEQUENCE =
sig
  structure Seq : SEQUENCE

  type 'a t
  type 'a stseq = 'a t

  exception Range

  val fromSeq : 'a Seq.t -> 'a stseq
  val toSeq : 'a stseq -> 'a Seq.t
  val nth : 'a stseq -> int -> 'a

  val update : ('a stseq * (int * 'a)) -> 'a stseq
  val inject : ('a stseq * (int * 'a) Seq.t) -> 'a stseq
end
\end{verbatim}
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Substructures
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Substructures
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
Seq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Seq
]]>
</field> <!-- title_src -->
<field name='label'>
gr:st-seq-interface:Seq
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>structure Seq : SEQUENCE  </code></pre>
<p>Defines the underlying sequence type to and from which single-threaded sequences can be converted.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
structure Seq : SEQUENCE
\end{verbatim}
Defines the underlying sequence type to and from which single-threaded
sequences can be converted.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Types
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Types
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>type &#39;a t  
type &#39;a stseq = &#39;a t  </code></pre>
<p>The abstract single-threaded sequence type <code>’a t</code> has elements of type <code>’a</code>. The alias <code>’a stseq</code> is for readability.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
type 'a t
type 'a stseq = 'a t
\end{verbatim}
The abstract single-threaded sequence type \sml{'a t} has elements of type
\sml{'a}. The alias \sml{'a stseq} is for readability.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Exceptions
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Exceptions
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>exception Range  </code></pre>
<p>The <code>Range</code> exception is raised whenever an invalid index into a sequence is used.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
exception Range
\end{verbatim}
The \sml{Range} exception is raised whenever an invalid index into a sequence
is used.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Values
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Values
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
fromSeq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
fromSeq
]]>
</field> <!-- title_src -->
<field name='label'>
gr:st-seq-interface:fromSeq
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val fromSeq : &#39;a Seq.t -&gt; &#39;a stseq  </code></pre>
<p>Convert a sequence to a single-threaded sequence.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val fromSeq : 'a Seq.t -> 'a stseq
\end{verbatim}
Convert a sequence to a single-threaded sequence.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toSeq
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toSeq
]]>
</field> <!-- title_src -->
<field name='label'>
gr:st-seq-interface:toSeq
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toSeq : &#39;a stseq -&gt; &#39;a Seq.t  </code></pre>
<p>Convert a single-threaded sequence to a standard sequence.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toSeq : 'a stseq -> 'a Seq.t
\end{verbatim}
Convert a single-threaded sequence to a standard sequence.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
nth
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
nth
]]>
</field> <!-- title_src -->
<field name='label'>
gr:st-seq-interface:nth
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val nth : &#39;a stseq -&gt; int -&gt; &#39;a  </code></pre>
<p><code>nth s i</code> returns the <span class="math inline">\(i^\text{th}\)</span> element of <span class="math inline">\(s\)</span>. Raises <code>Range</code> if <span class="math inline">\(i\)</span> is out-of-bounds.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val nth : 'a stseq -> int -> 'a
\end{verbatim}
\sml{nth s i} returns the $i^\text{th}$ element of $s$. Raises \sml{Range}
if $i$ is out-of-bounds.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
update
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
update
]]>
</field> <!-- title_src -->
<field name='label'>
gr:st-seq-interface:update
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val update : (&#39;a stseq * (int * &#39;a)) -&gt; &#39;a stseq  </code></pre>
<p><code>update (s, (i, x))</code> evaluates to a new single-threaded sequence where the <span class="math inline">\(i^\text{th}\)</span> element of <span class="math inline">\(s\)</span> has been replaced by <span class="math inline">\(x\)</span>, but all other elements are the same as in <span class="math inline">\(s\)</span>. Raises <code>Range</code> if <span class="math inline">\(i\)</span> is out-of-bounds.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val update : ('a stseq * (int * 'a)) -> 'a stseq
\end{verbatim}
\sml{update (s, (i, x))} evaluates to a new single-threaded sequence where
the $i^\text{th}$ element of $s$ has been replaced by $x$, but all other
elements are the same as in $s$. Raises \sml{Range} if $i$ is out-of-bounds.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
inject
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
inject
]]>
</field> <!-- title_src -->
<field name='label'>
gr:st-seq-interface:inject
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val inject : (&#39;a stseq * (int * &#39;a) Seq.t) -&gt; &#39;a stseq  </code></pre>
<p><code>inject (s, u)</code> evaluates to a new single-threaded sequence where, for each <span class="math inline">\((i,x) \in u\)</span>, the <span class="math inline">\(i^\text{th}\)</span> element of <span class="math inline">\(s\)</span> has been replaced by <span class="math inline">\(x\)</span>, but all other elements are the same as in <span class="math inline">\(s\)</span>. If there are duplicate indices in <span class="math inline">\(u\)</span>, one of them “wins” non-deterministically, and the others are ignored. Raises <code>Range</code> if any of the indices in <span class="math inline">\(u\)</span> is out-of-bounds.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val inject : ('a stseq * (int * 'a) Seq.t) -> 'a stseq
\end{verbatim}
\sml{inject (s, u)} evaluates to a new single-threaded sequence where, for
each $(i,x) \in u$, the $i^\text{th}$ element of $s$ has been replaced by $x$,
but all other elements are the same as in $s$. If there are duplicate indices
in $u$, one of them ``wins'' non-deterministically, and the others are ignored.
Raises \sml{Range} if any of the indices in $u$ is out-of-bounds.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->

</block> <!-- chapter -->
