<?xml version="1.0" encoding="UTF-8"?>
<block name='chapter'>
<field name='title'>
<![CDATA[
Key Interfaces
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Key Interfaces
]]>
</field> <!-- title_src -->
<field name='label'>
ch:key-interface
</field> <!-- label -->
<atom name='preamble'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>EQKEY</code>, <code>ORDKEY</code>, and <code>HASHKEY</code> signatures specify abstract key types which support various forms of equality testing and comparison.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{EQKEY}, \sml{ORDKEY}, and \sml{HASHKEY} signatures specify abstract
key types which support various forms of equality testing and comparison.
]]>
</field> <!-- body_src -->
</atom> <!-- preamble -->

<block name='section'>
<field name='title'>
<![CDATA[
Summary
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Summary
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>EQKEY</code> signature specifies a key which can only be tested for equality.</p>
<pre><code>signature EQKEY =  
sig  
  type t  
  val equal : t * t -&gt; bool  
  val toString : t -&gt; string  
end  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{EQKEY} signature specifies a key which can only be tested for
equality.
\begin{verbatim}
signature EQKEY =
sig
  type t
  val equal : t * t -> bool
  val toString : t -> string
end
\end{verbatim}
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>ORDKEY</code> signature specifies a key which, in addition to supporting equality, is also totally ordered. Any structure which ascribes to <code>ORKEY</code> also implicitly ascribes to <code>EQKEY</code>.</p>
<pre><code>signature ORDKEY =  
sig  
  include EQKEY  
  val compare : t * t -&gt; order  
end  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{ORDKEY} signature specifies a key which, in addition to supporting
equality, is also totally ordered. Any structure which ascribes to \sml{ORKEY}
also implicitly ascribes to \sml{EQKEY}.
\begin{verbatim}
signature ORDKEY =
sig
  include EQKEY
  val compare : t * t -> order
end
\end{verbatim}
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<p>The <code>HASHKEY</code> signature specifies a key which additionally offers a pseudo-random hashing operation. Any structure which ascribes to <code>HASHKEY</code> also implicitly ascribes to both <code>ORDKEY</code> and <code>EQKEY</code>.</p>
<pre><code>signature HASHKEY =  
sig  
  include ORDKEY  
  val hash : t -&gt; int  
end  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \sml{HASHKEY} signature specifies a key which additionally offers a
pseudo-random hashing operation. Any structure which ascribes to \sml{HASHKEY}
also implicitly ascribes to both \sml{ORDKEY} and \sml{EQKEY}.
\begin{verbatim}
signature HASHKEY =
sig
  include ORDKEY
  val hash : t -> int
end
\end{verbatim}
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->
<block name='section'>
<field name='title'>
<![CDATA[
Types and Values
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Types and Values
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>type t  </code></pre>
<p>The abstract key type.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
type t
\end{verbatim}
The abstract key type.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
equal
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
equal
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val equal : t * t -&gt; bool  </code></pre>
<p>Determine whether or not the arguments are considered equal. This function is reflexive, symmetric, and transitive.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val equal : t * t -> bool
\end{verbatim}
Determine whether or not the arguments are considered equal. This function is
reflexive, symmetric, and transitive.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
toString
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
toString
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val toString : t -&gt; string  </code></pre>
<p>Return a string representation of the key.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val toString : t -> string
\end{verbatim}
Return a string representation of the key.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
compare
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
compare
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val compare : t * t -&gt; order  </code></pre>
<p>Return one of <code>LESS</code>, <code>EQUAL</code>, or <code>GREATER</code> as appropriate for the argument pair. This operation is transitive. It is also consistent: <code>compare(x,y) = EQUAL</code> if and only if <code>equal(x,y)</code>, and <code>compare(x,y) = LESS</code> if and only if <code>compare(y,x) = GREATER</code>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val compare : t * t -> order
\end{verbatim}
Return one of \sml{LESS}, \sml{EQUAL}, or \sml{GREATER} as appropriate for
the argument pair. This operation is transitive. It is also consistent:
\sml{compare(x,y) = EQUAL} if and only if \sml{equal(x,y)}, and
\sml{compare(x,y) = LESS} if and only if \sml{compare(y,x) = GREATER}.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->
<atom name='gram'>
<field name='title'>
<![CDATA[
hash
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
hash
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='body'>
<![CDATA[
<pre><code>val hash : t -&gt; int  </code></pre>
<p>Return a pseudo-random hash.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
val hash : t -> int
\end{verbatim}
Return a pseudo-random hash.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->


</block> <!-- section -->

</block> <!-- chapter -->
